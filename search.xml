<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/"/>
      <url>/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>每一个服务都有自己的ip和端口，<strong>微服务</strong>是一种软件架构风格，它是以专注于单一职责的很多小型项目为基础，组合出复杂的大型应用。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240711145457534.png" alt="image-20240711145457534" style="zoom:50%;"><h2 id="Docker-：必须要知道"><a href="#Docker-：必须要知道" class="headerlink" title="Docker ：必须要知道"></a>Docker ：必须要知道</h2><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240712101118216.png" alt="image-20240712101118216"></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814202052638.png" alt="image-20240814202052638"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">创建mysql容器</span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql:8.0.26</span><br><span class="line">  </span><br><span class="line">创建redis容器</span><br><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">--name redis \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">--restart unless-stopped \</span><br><span class="line">-v /data/soft/redis/data:/data \</span><br><span class="line">-v /data/soft/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">redis:6.2.7 \</span><br><span class="line">redis-server /etc/redis/redis.conf \</span><br><span class="line">--appendonly <span class="built_in">yes</span></span><br><span class="line">容器在退出后会自动重启，除非手动停止。</span><br><span class="line">开启 AOF 持久化模式。这意味着 Redis 服务器会将所有写入操作记录到一个名为 appendonly.aof 的文件中，即使服务器意外重启，也可以通过读取这个文件来恢复数据。</span><br><span class="line"></span><br><span class="line">创建Gogs容器</span><br><span class="line">docker run -p 10022:22 -p 10880:3000 --name=gogs \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -v /data/soft/gogs:/data \</span><br><span class="line">  -d gogs/gogs:latest</span><br><span class="line">-p 10022:22 将容器的22端口映射到宿主机的10022端口，用于SSH服务。</span><br><span class="line">-p 10080:3000 将容器的3000端口映射到宿主机的10080端口，用于Web访问。</span><br><span class="line">注意必须要改gogs配置文件中的ip地址</span><br><span class="line">app.ini不要copy虚拟机的，这个是在完成初始化后自己生成的md，高了一天</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建xxl-job-admin容器</span><br><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-e PARAMS=<span class="string">&quot;--spring.datasource.url=jdbc:mysql://172.17.0.2:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 --spring.datasource.username=root --spring.datasource.password=123456&quot;</span> \</span><br><span class="line">-p 8088:8080 \</span><br><span class="line">-v /data/soft/applogs:/data/applogs \</span><br><span class="line">--name xxl-job-admin \</span><br><span class="line">xuxueli/xxl-job-admin:2.3.1</span><br><span class="line"></span><br><span class="line">创建minio容器</span><br><span class="line">docker run \</span><br><span class="line">-p 9001:9000 \ 连接端口号</span><br><span class="line">-p 9090:9090 \ 后台管理控制台端口号</span><br><span class="line">--name minio \</span><br><span class="line">-d --restart=always \</span><br><span class="line">-e <span class="string">&quot;MINIO_ACCESS_KEY=minioadmin&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;MINIO_SECRET_KEY=minioadmin&quot;</span> \</span><br><span class="line">-v /data/soft/minio/data:/data \</span><br><span class="line">-v /data/soft/minio/config:/root/.minio \</span><br><span class="line"> minio/minio:RELEASE.2022-09-07T22-25-02Z server \</span><br><span class="line">/data --console-address <span class="string">&quot;:9090&quot;</span> -address <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h2><p>拆分服务：独立Project（文件夹和project）和<strong>Maven聚合</strong>（：和module）单体架构师所有功能写到一个module中</p><p>聚合起来才能成为一个工程</p><p><code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖</p><p>有总的父工程parent，和模块的父工程，父工程都为<packaging>pom</packaging>，当 <code>&lt;packaging&gt;</code> 元素的值为 <code>pom</code> 时，表示该项目是一个父项目或聚合项目（aggregation project），而不是一个实际的可执行或可部署的项目。这种类型的项目主要用于管理多个子项目的共同配置和依赖。</p><p>在没有前后端分离之前，响应的是html页面，现在前后端分离，响应的是json</p><p>公共类放到base中去</p><p>你想将对象存储在redis中的时候就需要序列化就需要实现Serializable接口</p><p>如果要直接在网络上传递一个javabean 2.A服务 远程调用 B服务的 javaBean对象数据</p><p>你注意你启动类放在了com xuecheng下面，那么最后编译完只要是com xuecheng下面的 component 也好 configuration也好都能扫描到</p><p>把启动类放到com.xuecheng 会将该包以及子包下的所有bean都扫描到，com.xuecheng为项目的根包，<strong>当时就碰到问题日期的配置类一直扫描不到就是因为下面图片这个原因</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240716171758145.png" alt="image-20240716171758145" style="zoom:33%;"><h2 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h2><p><strong>从下向上开发，定义接口–&gt;先开发Mapper–&gt;再开发Service–&gt;最后再完善接口</strong></p><h3 id="开发持久层"><a href="#开发持久层" class="headerlink" title="开发持久层"></a>开发持久层</h3><p>需要扫描copy到Service工程中的Mapper以生成这些Mapper接口的代理对象放到Spring容器中@MapperScan(“com.xuecheng.content.mapper”)，定义分页插件（原理：写sql语句会自动加limit分页的sql语句）</p><p>启动测试需要启动类，@SpringBootApplication自动装配原理，把启动类所在包以及子包所有bean扫描以及注入到容器中，把Mapper（虽然是接口但是会生成代理对象，注入到Spring容器），要测试哪个Mapper就需要在单元测试类中，从Spring容器中把它拿到注入到单元测试类中。</p><p>方法引用，进一步简化Lambda表达式   </p><p>Mapper是不需要写实现类的只写接口就行 ，将来会使用MyBatis基于动态代理生成实现类</p><p>MyBatisPlus通过扫描实体类，并基于反射获取<strong>实体类信息</strong>作为数据库表信息 </p><p>public interface CourseBaseMapper extends BaseMapper<CourseBase> {&#x2F;&#x2F;关键要制定泛型也就是我们实体类的类型}</CourseBase></p><p>MP基于反射得到实体类CourseBase的类型，通过反射拿到字节码从而拿到实体类信息，再将实体类信息作为数据库表信息</p><p>约定如下：如果不符合约定的话就需要自己去标记</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240716144049202.png" alt="image-20240716144049202"></p><p>MP的条件构造器有两大类</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240716161435031.png" alt="image-20240716161435031"></p><h3 id="开发业务层"><a href="#开发业务层" class="headerlink" title="开发业务层"></a>开发业务层</h3><p>创建数据字典表，将一些状态对应为一些代码–&gt;编写Service–&gt;测试Service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页对象</span></span><br><span class="line">  Page&lt;CourseBase&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">  <span class="comment">// 查询数据内容获得结果</span></span><br><span class="line">  Page&lt;CourseBase&gt; pageResult = courseBaseMapper.selectPage(page, queryWrapper);</span><br></pre></td></tr></table></figure><p>接口测试中，考虑到Swagger不能保存测试数据，因此可以使用测试工具httpclient来进行测试。</p><h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><p>导入前端工程–&gt;安装系统管理服务（因为前端要请求获取数据字典表数据），前后端联调发现有跨域</p><p>服务器之间不存在跨域，服务器程序之间访问不会跨域 跨域其实数据已经取到了，只是因为浏览器的策略把显示或者说渲染这部给阻止了</p><h3 id="课程分类查询"><a href="#课程分类查询" class="headerlink" title="课程分类查询"></a>课程分类查询</h3><p>开发思路：根据接口分析拿到的数据     定义模型类dto   然后定义接口api   开发接口 （开发Mpper–&gt;开发Service对接接口，因为数据都已经拿到了但是格式不对，service负责将数据封装成接口需要的结果，即处理子节点) </p><p>Service代码实现如下</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240718151209415.png" alt="image-20240718151209415"></p><p>自动生成的Mapper不能满足我们的使用递归的sql要求因此需要自定义</p><p>CourseCategoryTreeDti是带有子节点的扩展模型类</p><p>resultType，resultMap查询出来的字段的名和模型属性不一致使用resultMap重新映射</p><p><strong>注意一下：</strong>在xml自定义sql中，course_category会爆红但不报错，其实多个数据都有course_category表，但在Resource中我们连接了xc_content数据库，那么他会默认连接xc_content的表</p><h4 id="这里的递归sql很关键"><a href="#这里的递归sql很关键" class="headerlink" title="这里的递归sql很关键"></a>这里的递归sql很关键</h4><h3 id="新增课程"><a href="#新增课程" class="headerlink" title="新增课程"></a>新增课程</h3><p>使用两个dto：AddCourseDto（接受前端传过来的数据）和CourseBaseInfoDto（其实应该是VO，这个项目感觉解释dto和vo有点问题，所有都用dto）</p><p>课程基本信息、课程营销信息也就是course_base、course_market是一对一的关联关系</p><p>course_base还有一个机构id信息，用户不需要输入，单点登录后拿到用户的机构id然后传递给Service，审核状态和发布状态都是默认的</p><p>由于向两张表写数据，加上事务控制注解@Transactional</p><p>抛Exception事务会失效？</p><p>遇到的困难：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在查到营销表中没有数据的时候就插入，使用了属性copy但要知道courseMarket为空所以会报错，</span></span><br><span class="line">BeanUtils.copyProperties(courseMarketNew,courseMarket);</span><br><span class="line"><span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> courseMarketMapper.insert(courseMarket);</span><br><span class="line"><span class="comment">//应该直接这样就好</span></span><br><span class="line"><span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> courseMarketMapper.insert(courseMarketNew);</span><br></pre></td></tr></table></figure><p>面试题：</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240719164508029.png" alt="image-20240719164508029" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240719164340136.png" alt="image-20240719164340136" style="zoom:33%;"><p>异常处理，统统向上抛出，抛给框架让框架进行处理</p><p>首先要自定义自己的异常类型，和前端约定返回的异常信息为json，json属性为errMessage（无论是自定义异常还是系统异常统统封装成一个类型返回），最后编写异常处理器（框架提供两个注解增强控制器统一捕获异常 ）</p><p>@ControllerAdvice:底层，AOP</p><p>@ExceptionHandler制定某一个方法对某一个异常的类型进行捕获</p><h4 id="面试："><a href="#面试：" class="headerlink" title="面试："></a>面试：</h4><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240719190745992.png" alt="image-20240719190745992"></p><h2 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h2><h3 id="JSR303校验"><a href="#JSR303校验" class="headerlink" title="JSR303校验"></a>JSR303校验</h3><p>JSR303抛出MethodArgumentNotValidException异常，我们要在异常处理中解析这个异常</p><p>Service中主要对业务逻辑进行校验，如<strong>校验本机构只能修改本机构的课程</strong>。</p><p>@Validated激活注解校验</p><p>思考：校验规则都是在模型类上配置的，那么如果多个接口使用统一个模型类会出现什么问题，如，新增课程时课程id为空，修改课程时id不能为空，多个接口对校验的需求不同。</p><p>答：使用分组校验</p><h3 id="修改课程"><a href="#修改课程" class="headerlink" title="修改课程"></a>修改课程</h3><p>修改课程的<strong>第一个接口</strong>就是通过id查询课程</p><p>修改比新增的表单多一个课程id，因此要重新定义一个模型类相比新增课程模型类AddCourseDto多一个id属性。下面这个课程id应该为id不能是courseId，因为前端传过来的是Id，并不是courseId</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240720135745927.png" alt="image-20240720135745927" style="zoom:25%;"><p>不用写mapper因为需要两张表coursebase和coursemarket，mp把两张表mapper都生成好了，他们都具有根据id查课程，而且Service中的getCourseBaseById也不用写只需添加到接口就行，具体方法在新增课程中写过了。</p><p>修改课程时候依然要传入机构id</p><p>表单类的校验都在接口层，在Service层需要进行业务逻辑校验，例如机构1的用户无法修改机构2的课程</p><p>数据校验添加分组后没有添加分组不回进行校验，如下</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240720153749466.png" alt="image-20240720153749466" style="zoom:33%;"><p>视频中只有更新课程基本信息，没有<strong>更新课程营销信息，自己实现</strong></p><h3 id="查询课程计划"><a href="#查询课程计划" class="headerlink" title="查询课程计划"></a>查询课程计划</h3><p>需要课程计划表，teachplan，课程计划与媒资关系表，teach plan_media，用于课程计划关联视频，<strong>视频只关联小章节</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240720155438325.png" alt="image-20240720155438325" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240720155537610.png" alt="image-20240720155537610" style="zoom:33%;"><p>生成的Mapper无法满足我们的树形查询方式</p><ul><li>如果分类的级数比较少可以用表的自连接，这里就是大章节和小章节两集，直接使用表的自连接。</li><li>如果比较多可以用递归sql</li></ul><p>表的自连接+左外连接</p><p>左外连接：<strong>无论右边有没有，左边都会显示</strong>（一级分类和二级分类通过teachplan表的自链接进行，如果只有一级分类其下边没有二级分类，此时也需要显示一级分类，这里使用左连接，左边是一级分类，右边是二级分类。）</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240720163539924.png" alt="image-20240720163539924" style="zoom:33%;"><p>查询出的数据与模型类不对应需要使用resultMap自定义映射</p><p>type是返回的最终类型，因为这个类型的属性和查出来的数据不一致，需要手动映射</p><p>主键字段用id，普通字段用result</p><p>一对多映射使用<collection>,一个大章节有多个小章节，list中的属性为ofType</collection></p><p>一对一映射，<association>小章节和视频是一对一的关系，映射的类型叫javaType</association></p><h4 id="sql语句很关键"><a href="#sql语句很关键" class="headerlink" title="sql语句很关键"></a>sql语句很关键</h4><h3 id="新增-修改课程计划"><a href="#新增-修改课程计划" class="headerlink" title="新增&#x2F;修改课程计划"></a>新增&#x2F;修改课程计划</h3><p>teachplan中的grade字段，1对应大章节、2对应小章节</p><p>下面三个操作使用一个接口，新增模型类SaveTeachplanDto用来接受下面三种操作请求的数据</p><p>难度在Service编写</p><ul><li><p>添加章</p></li><li><p>添加小结</p></li><li><p>修改信息</p></li></ul><p>前端会传来{  “courseId” : 74,  “parentid”: 0,  “grade” : 1,  “pname” : “新章名称 [点击修改]” }这四个数据</p><p>新增数据后，通过orderby字段来进行排序</p><p><strong>文档一些代码存在问题</strong>count也没加+1</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240720220929590.png" alt="image-20240720220929590" style="zoom:33%;"><h3 id="Bug修改："><a href="#Bug修改：" class="headerlink" title="Bug修改："></a>Bug修改：</h3><p>把TeachplanMapper.xml里面的内连接inner join teachplan two on two.parentid &#x3D; one.id改为左外连接left join teachplan two on two.parentid &#x3D; one.id原因:内连的时候新增大章节,而表2并没有数据以新增大章节为父节点.内连,没有公共部分,所以不会显示</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240721093719045.png" alt="image-20240721093719045" style="zoom:33%;"><p>order by one.orderby,two.orderby&#x2F;&#x2F;当表1的orderby字段相同时，比较two的orderby</p><h2 id="sql多表查询"><a href="#sql多表查询" class="headerlink" title="sql多表查询"></a>sql多表查询</h2><p>  一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</p><p>表结构：emp,dept</p><p>连接条件：emp.dept_id &#x3D; dept.id</p><h3 id="内连接："><a href="#内连接：" class="headerlink" title="内连接："></a><strong>内连接：</strong></h3><p>相当于查询A、B交集部分数据（查询的是两张表交集的部分）</p><ul><li>隐式内连接</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> , 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ... ;</span><br></pre></td></tr></table></figure><ul><li>显式内连接：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [ <span class="keyword">INNER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 ... ;</span><br></pre></td></tr></table></figure><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240721104039839.png" alt="image-20240721104039839" style="zoom:33%;"><h3 id="外连接："><a href="#外连接：" class="headerlink" title="外连接："></a><strong>外连接：</strong></h3><p>(内连接会有一条数据查询不出来，因为他没有关联的数据)</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240721105104884.png" alt="image-20240721105104884"></p><ul><li>左外连接：左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure><ul><li>右外连接：右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [ <span class="keyword">OUTER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ... ;</span><br></pre></td></tr></table></figure><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240721104617522.png" alt="image-20240721104617522" style="zoom:33%;"><h3 id="自连接："><a href="#自连接：" class="headerlink" title="自连接："></a><strong>自连接：</strong></h3><p>对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件 ... ;</span><br><span class="line">在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底</span><br><span class="line">是哪一张表的字段。</span><br></pre></td></tr></table></figure><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240721110503146.png" alt="image-20240721110503146" style="zoom:33%;"><h3 id="联合查询："><a href="#联合查询：" class="headerlink" title="联合查询："></a>联合查询：</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ... <span class="keyword">UNION</span> [ <span class="keyword">ALL</span> ]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ....;</span><br><span class="line">对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span> 会将全部的数据直接合并在一起，<span class="keyword">union</span> 会对合并之后的数据去重。</span><br></pre></td></tr></table></figure><h2 id="day04项目实战对应分支dev04"><a href="#day04项目实战对应分支dev04" class="headerlink" title="day04项目实战对应分支dev04"></a>day04项目实战对应分支dev04</h2><h3 id="删除课程计划"><a href="#删除课程计划" class="headerlink" title="删除课程计划"></a>删除课程计划</h3><p>挺简单的</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240724211941553.png" alt="image-20240724211941553"></p><h3 id="课程计划排序"><a href="#课程计划排序" class="headerlink" title="课程计划排序"></a>课程计划排序</h3><p>和这个人cyborg2077想的基本一样，只不过不太会用mp查询找出order的仅下一个（都考虑到了order不一定连续），直接用条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.orderByAsc(Teachplan::getOrderby)</span><br><span class="line">                    .last(&quot;LIMIT 1&quot;);就ok了</span><br></pre></td></tr></table></figure><p>这个人直接一口接口实现了，传递俩参数，又一个为moveType来确定是movedown还是moveon</p><p>但是这个人感觉弄麻烦了，他分为两种，大章节使用parentId来查同级课程、小章节用courseId来查同级课程，我直接一起无论大章节小章节只要他们这两个id相同就是他的同级课程</p><p>Mabatis Plus中条件语句中</p><p>gt(great than)表示大于，ge(greater than or equal to)大于等于</p><p>lt(less than)表示小于，le(less than or equal to)小于等于</p><h3 id="师资管理"><a href="#师资管理" class="headerlink" title="师资管理"></a>师资管理</h3><p><strong>我直接将这些所有写在了tenchplancontroller，没有重新定义controller，因为觉得这些也是属于课程计划的一部分，毕竟也是在课程计划之后执行的</strong></p><h4 id="查询教师"><a href="#查询教师" class="headerlink" title="查询教师"></a>查询教师</h4><h4 id="添加教师、修改教师为一个接口"><a href="#添加教师、修改教师为一个接口" class="headerlink" title="添加教师、修改教师为一个接口"></a>添加教师、修改教师为一个接口</h4><p>参考这个，课程id，courseBaseNew插入成功后自动生成id，通过主键找到课程基本信息对应的营销数据</p><p><strong>在插入教师表后会生成教师id，接着我们可以通过couseTeacher.getId()获取教师id</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240725220026365.png" alt="image-20240725220026365" style="zoom:33%;"><p><strong>前端这里修改老师的接口和新增调用的是post，应该写在一个接口里面</strong></p><p>从接口示例中可以看到，新增和删除用的是同一个接口，判断请求是新增还是删除，是根据请求参数中是否传递了id来决定的</p><ul><li>请求参数中没有id，则为新增教师</li><li>请求参数中有id，则为修改教师</li></ul><p>这里我设置CourseTeacherDto和CourseTeacher其实是一样的，也可不设置</p><p><strong>@Transactional是啥作用来着，看看苍穹外卖项目</strong>，为啥要对这个操作加上这个注解</p><p>对两张表写数据，凡是增删改的方法都要加上事务控制注解</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240726104721908.png" alt="image-20240726104721908" style="zoom:33%;"><p>方法没有执行完事务不会提交，表中还不会插入数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1TP411v7v6?p=115&amp;vd_source=6490e6a4523af5eeda2b4c5dae27592a</span><br></pre></td></tr></table></figure><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240726105731474.png" alt="image-20240726105731474" style="zoom:33%;"><h4 id="删除教师，都挺简单"><a href="#删除教师，都挺简单" class="headerlink" title="删除教师，都挺简单"></a>删除教师，都挺简单</h4><h3 id="删除课程"><a href="#删除课程" class="headerlink" title="删除课程"></a>删除课程</h3><p>注意操作多表还是要加入transactional注解</p><h2 id="day05媒资管理模块"><a href="#day05媒资管理模块" class="headerlink" title="day05媒资管理模块"></a>day05媒资管理模块</h2><p><strong>用于管理课程相关的媒体资源</strong>：视频、文档等</p><p><strong>内容管理服务</strong> 的课程计划信息和<strong>媒资管理服务</strong> 的上传的视频进行绑定</p><p>搭建Nacos–&gt;搭建网关（对请求进行路由和转发，转到某一个ip和端口上）–&gt;开发媒资管理微服务</p><p>项目采用<strong>Spring Cloud Gateway作为网关</strong>，网关在请求路由时需要知道每个微服务实例的地址，项目使用<strong>Nacos作用服务发现中心和配置中心</strong>，整体的架构图如下：一个服务可以有多个实例，如内容管理服务可以有两个JVM（服务器），网关会进行负载均衡。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240726151952643.png" alt="image-20240726151952643" style="zoom:33%;"><p>流程如下：</p><p>1、微服务启动，将自己注册到Nacos，Nacos记录了各微服务实例的地址。</p><p>2、网关从Nacos读取服务列表，包括服务名称、服务地址等。</p><p>3、请求到达网关，网关将请求路由到具体的微服务。</p><p>要使用网关首先搭建Nacos，Nacos有两个作用：</p><p><strong>1、服务发现中心。</strong></p><p>微服务将自身注册至Nacos，网关从Nacos获取微服务列表。</p><p><strong>2、配置中心。</strong></p><p>微服务众多，它们的配置信息也非常复杂，为了提供系统的可维护性，微服务的配置信息统一在Nacos配置。</p><h3 id="搭建Nacos"><a href="#搭建Nacos" class="headerlink" title="搭建Nacos"></a>搭建Nacos</h3><p>Spring Cloud ：一套规范</p><p>Spring Cloud alibaba: 对Spring Cloud规范的实现，提供了nacos服务注册中心，配置中心、远程调用feign等各种解决方案</p><p>记得先改nacos配置文件中的数据库地址</p><p>如果远程调用接口比较频繁，建议使用dubbo（基于rpc协议）</p><p><strong>服务发现中心</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//将内容管理微服务上报nacos</span><br><span class="line">该服务有三个工程，api工程启动的是http服务需要往上报</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置中心</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">配置客户端定时从nacos拉去配置，会有一个客户端程序与nacos建立连接</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在正式环境中，每个服务至少有两个实例以此来保证其容错性，如果以后要改数据库的地址那得累死</p><p><strong>通过Nacos去管理项目的所有配置，直接在nacos软件中手动更改配置</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240726165800649.png" alt="image-20240726165800649" style="zoom:33%;"><p>config客户端从nacos中请求获取配置，通过post方式从nacos中获取配置</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240726173138032.png" alt="image-20240726173138032"></p><p>配置文件名为</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240726173503446.png" alt="image-20240726173503446" style="zoom:33%;"><p>service不注册服务，只需要配置文件相关配置，因为service不用被其他微服务调用，其他微服务调用的是api，</p><p>为什么要配置service配置文件到nacos，因为<strong>api接口层</strong>其实本来不应该需要数据库连接，是因为api层依赖了service层代码，每次启动api层时，会把service层的mapper和service代码全部依赖到自己的工程，这些代码需要所以api需要数据库配置。但是api层本身的代码不需要数据库连接。</p><p><strong>所以应该这样做</strong>：service在nacos配置自己的配置文件，然后使用api来引用service工程配置文件，content-api-dev.yaml是接口特有的配置文件，不需要数据库连接配置应该来引用service工程配置文件。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">##api接口的配置文件，拉取了nacos的四个配置文件 </span></span><br><span class="line"><span class="comment">#1.自己特有的配置文件</span></span><br><span class="line"><span class="comment">#2.依赖service的配置文件</span></span><br><span class="line"><span class="comment">#3.公用的配置文件swagger</span></span><br><span class="line"><span class="comment">#4.公用的配置文件logging</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">content-api</span> <span class="comment">#服务名   配置文件名 content-api-dev.yaml</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">172.24</span><span class="number">.40</span><span class="number">.60</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> <span class="comment">#注册到nacos中 服务注册相关配置</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev_xcplus</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config:</span> <span class="comment">#使用配置中心  配置文件相关配置</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev_xcplus</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#扩展名yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">extension-configs:</span> <span class="comment">#因为api接口工程依赖了service工程 的jar，这里采用依赖service的配置文件</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">content-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">xuecheng-plus-project</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">swagger-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#profiles默认为dev</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>各配置文件 的优先级：项目应用名配置文件 &gt; 扩展配置文件  &gt; 共享配置文件 &gt; 本地配置文件。</p><p>注意：在配置system-api和service的nacos配置文件时，service的配置文件原先为application.yml需要改为bootstrap.yml,要不一致出问题。</p><h3 id="搭建网关"><a href="#搭建网关" class="headerlink" title="搭建网关"></a>搭建网关</h3><p>网关端口为63010</p><p>新建网关工程–&gt;配置网关的bootstrap.yaml配置文件–&gt;在http-client-env.json中配置网关的地址–&gt;使用httpclient测试课程查询 接口</p><h3 id="搭建媒资服务工程"><a href="#搭建媒资服务工程" class="headerlink" title="搭建媒资服务工程"></a>搭建媒资服务工程</h3><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><p>单体系统拆分为若干微服务，这些微服务会独立部署–&gt;分布式</p><p><strong>通过网络将若干计算机组织起来共同去提供存储和访问文件的服务，就是分布式文件系统。</strong></p><p>本项目采用MInIO构建分布式文件系统，Minio使用纠删码技术来保护数据，使用纠删码的好处是即便丢失一半数量（N&#x2F;2）的硬盘，仍然可以恢复数据。</p><p>实际生产环境有4个结点，<strong>我们开发只部署一个结点</strong></p><p><strong>使用okhttp库想minIO上传文件</strong>,minIO的sdk是一些工具类库帮助我们快速集成minIO上传下载删除文件</p><p>9001是他网站的端口，sdk提供的接口应该是9000</p><ul><li><code>--console-address &quot;:9000&quot;</code>：指定MinIO控制台端口，确保任何尝试连接到这个端口的客户端或应用程序都可以使用这个端口</li><li><code>--address &quot;:9001&quot;</code>：指定MinIO服务端口，将Docker守护程序绑定到指定的端口上</li></ul><p>tmd win忘了开9000端口导致找bug找了半天连不上</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240727192059374.png" alt="image-20240727192059374" style="zoom:33%;"><p>Content-Type（MediaType），即是Internet Media Type，互联网媒体类型，也叫做<a href="https://so.csdn.net/so/search?q=MIME%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">MIME类型</a>。</p><p>text&#x2F;plain：纯文本格式；<br>text&#x2F;html：HTML格式；<br>text&#x2F;css：Cascading Style Sheets；<br>text&#x2F;javascript：JavaScript代码；<br>application&#x2F;json：JSON格式数据；<br>application&#x2F;xml：XML格式数据；<br>application&#x2F;octet-stream：二进制流数据；<br>image&#x2F;jpeg：JPEG格式图片；<br>image&#x2F;gif：GIF格式图片；<br>image&#x2F;png：PNG格式图片；<br>audio&#x2F;mpeg：MP3格式音频；<br>video&#x2F;mp4：MP4格式视频；<br>multipart&#x2F;form-data：表单数据；</p><p>校验文件的完成性对文件的内容进行md5<br>校验时  使用原始文件（本地流） 和 下载到的文件（输出流） 进行对比</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240727195311668.png" alt="image-20240727195311668"></p><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240727195655652.png" alt="image-20240727195655652" style="zoom:25%;"><p>上传图片是通过媒资服务（对文件进行统一管理）将图片上传到minIO</p><p>将文件本身的信息存在数据库media_files表中，将文件存放到分布式文件系统</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240727200014586.png" alt="image-20240727200014586" style="zoom:33%;"><p><strong>在media_files表中 bucket + file_path +  MinIO的值 可以浏览文件</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240727200421352.png" alt="image-20240727200421352" style="zoom:33%;"><p>创建两个桶mediafile（非视频，即使图片文档等）、video</p><p> 配置MinioConfig</p><p>使用springmvc去上传，程序属于消费者</p><p>单独建一个Dto响应给前端防止后面前端需要多穿一些数据，方便改动（直接用po不利于后期维护，万一后期要增加传进来的值就不好办了）</p><p>接口定义：（不懂，说使用了springmvc上传文件）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/upload/coursefile&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> UploadFileResultDto <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728101618329.png" alt="image-20240728101618329" style="zoom:33%;"><p>创建一个Dto UploadFileParamsDto用来接收文件信息，和mediafile相关的信息但是比mediafile中的属性少，例如没有id，上传以后才会有id</p><p><strong>这块好迷啊</strong>，<strong>抽取的独立方法太多了</strong></p><p>整体流程：</p><ul><li><p>上传图片接口。调用service的uploadFile</p></li><li><p>调用这个方法，干了两件事</p><ul><li>上传文件到Minio，这里对很多方法进行了封装，getMimeType()、getDefaultFolderPath()、getFileMd5()、addMediaFilesToMinIO()这四个方法。</li><li>将文件信息保存到数据库，封装了一个方法addMediaFilesToDb()。</li></ul></li><li><p>httpclient进行测试</p></li></ul><h3 id="Service事务优化：第一次碰到这种，很重要，如何解决事务失效"><a href="#Service事务优化：第一次碰到这种，很重要，如何解决事务失效" class="headerlink" title="Service事务优化：第一次碰到这种，很重要，如何解决事务失效"></a>Service事务优化：第一次碰到这种，很重要，如何解决事务失效</h3><p>上边的service方法优化后并测试通过，现在思考关于uploadFile方法的是否应该开启事务。</p><p>目前是在uploadFile方法上添加@Transactional，当调用uploadFile方法前会开启数据库事务，如果上传文件过程时间较长那么数据库的事务持续时间就会变长，这样数据库链接释放就慢，最终导致数据库链接不够用。</p><p>我们只将addMediaFilesToDb方法添加事务控制即可,uploadFile方法上的@Transactional注解去掉。</p><p><strong>只要有网络访问的东西千万不要进行事务控制</strong>，上传文件不放到事务控制里面，只放数据库操作</p><p>解决：代理对象+事务注解</p><p>注入进来的Service和Mapper都是代理对象</p><p><strong>开启事务和执行事务一定要是代理对象</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728113358655.png" alt="image-20240728113358655" style="zoom:25%;"><p><strong>非事务的方法调用事务的方法会出现事务失效</strong>：uploadFile非事务方法，调用加入了事务控制的addMediaFilesToDb事务方法。</p><p><strong>如何解决呢？</strong>使用代理对象调用addMediaFilesToDb方法。</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728113813011.png" alt="image-20240728113813011"></p><p>**这里解决出现循环依赖 **</p><p><strong>弹幕见解</strong>：</p><p>不会生效的，@Transactional这个注解本质时使用代理生成代理类进行处理的，本类自己调用时无法生成代理，所以不生效。和AOP差不多</p><p>调用入库的方法时，调用的是代理对象的入库方法，调用写minio方法的时候，调用的本身的方法，此时写数据库方法是没有被代理的，所以事务失效</p><p>有啥听不懂的，只有代理对象才有开启事务的功能啊，aop思想吗，代理对象是对被代理的对象的增强，这里没有被代理对象调用肯定没有事务的功能</p><h2 id="day06上传视频"><a href="#day06上传视频" class="headerlink" title="day06上传视频"></a>day06上传视频</h2><h3 id="上传视频"><a href="#上传视频" class="headerlink" title="上传视频"></a>上传视频</h3><p><strong>上传文档什么的就是使用上传图片的接口</strong>，上传视频的话需要另行处理</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728200127363.png" alt="image-20240728200127363" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728192709040.png" alt="image-20240728192709040" style="zoom:33%;"><p>上传分块：<strong>前端已经把分块啥的写好了</strong></p><p>前端需要四个接口，途中只有三个接口，但这里有考虑到在检查分块前应该还要<strong>检查文件是否存在</strong>，若存在则不进行后续操作</p><p>检查分块接口需要md5和分块序号才能找到分块，因为如下图chunk中文件名称就是序号</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728200441715.png" alt="image-20240728200441715" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728203057230.png" alt="image-20240728203057230" style="zoom:33%;"><p>上传分块的时候流程：</p><p>前端上传给媒资服务，媒资服务然后上传给minio</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728213657079.png" alt="image-20240728213657079" style="zoom:33%;"><p>改了前端改了配置，最终minio里能上传5mb</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728214931755.png" alt="image-20240728214931755"></p><p>接下来进行<strong>文件合并</strong>，主要包含四步：<strong>又抽取了很多方法</strong>，跟上传图片过程一样，这个是过程方法贼多</p><ul><li>先点用minio的合并方法进行合并</li><li>在校验合并后的文件和源文件是否一致</li><li>校验成功后，将文件信息入库</li><li>一切搞定了，最后清理分块</li></ul><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240728225916710.png" alt="image-20240728225916710" style="zoom:33%;"><p>文件合并的object()中文最终合并后的文件名字，是md5+扩展名</p><p>合并哪里老超时很奇怪：</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240729111448463.png" alt="image-20240729111448463" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240729133300549.png" alt="image-20240729133300549" style="zoom:33%;"><p><strong><code>file.transferTo(File dest)</code></strong>:</p><ul><li>这个方法用于将数据从当前文件对象传输到指定的目标文件。</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240729134228761.png" alt="image-20240729134228761" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240729134706637.png" alt="image-20240729134706637" style="zoom:33%;"><h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><h4 id="视频转码：FFmpeg工具"><a href="#视频转码：FFmpeg工具" class="headerlink" title="视频转码：FFmpeg工具"></a>视频转码：FFmpeg工具</h4><p>对一个视频的转码可以理解为一个任务的执行，如果视频的数量比较多，如何去高效处理一批任务呢？</p><p><strong>分布式+多线程</strong>：充分利用多台计算机，没太计算机使用多线程处理</p><p>任务调度：按照某个时间点或时间间隔执行任务</p><h4 id="分布式任务调度：多个计算机-同时进行任务调度，高效处理视频"><a href="#分布式任务调度：多个计算机-同时进行任务调度，高效处理视频" class="headerlink" title="分布式任务调度：多个计算机 同时进行任务调度，高效处理视频"></a>分布式任务调度：多个计算机 同时进行任务调度，<strong>高效处理视频</strong></h4><p><strong>实现任务调用，通过XXX-JOB中间件</strong>，主要包括调度中心、执行器、任务，<strong>有弹性扩容的机制</strong></p><p><strong>调度中心：</strong></p><p>​        负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码；</p><p>​        主要职责为执行器管理、任务管理、监控运维、日志管理等</p><p><strong>任务执行器：</strong></p><p>​        负责接收调度请求并执行任务逻辑；</p><p>​        只要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等</p><p><strong>任务：</strong>负责执行具体的业务处理。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240729205134561.png" alt="image-20240729205134561" style="zoom:33%;"><h4 id="xxl-job配置执行器"><a href="#xxl-job配置执行器" class="headerlink" title="xxl-job配置执行器"></a>xxl-job配置执行器</h4><p>执行器就是我们的微服务，service干活，在service中创建执行器</p><p>在service工程中添加jar包，包含了自动注册、下发任务代码，不用我们去写了，配置调动中心的地址等信息。微服务启动后，执行器会把自己报到调度中心。</p><p>但是service不具备独立启动的能力，我们通常启动api，api依赖service</p><p>执行器如何执行任务？</p><ul><li><p>先将执行器注册到调度中心</p></li><li><p>在微服务中定义一个任务类（这个任务类是spring的一个bean，jobhandler存放任务类）编写执行任务方法，并在方法上通过@XxlJob注解指定方法名称</p></li><li><p>在任务调度中心任务管理页面新增任务（将任务在调度中心中注册）</p></li></ul><p>启动调度中心 –&gt; 加入xxl-job核心代码依赖 –&gt; 配置xxl-job在nacos的配置 –&gt; 新增执行器 –&gt; 项目中添加执行器配置类 –&gt; 项目中添加任务类 –&gt;调度中心新增任务</p><p>运行模式有BEAN和GLUE，bean模式较常用就是在项目工程中编写执行器的任务代码，GLUE是将任务代码编写在调度中心。</p><h4 id="调度中心的路由策略"><a href="#调度中心的路由策略" class="headerlink" title="调度中心的路由策略"></a><strong>调度中心的路由策略</strong></h4><p>分片广播：调度中心任务将任务发给所有执行器，最大限度的提高分布式调度的执行能力（分片是指是调度中心以执行器为维度进行分片，将集群中的执行器标上序号：0，1，2，3…，广播是指每次调度会向集群中的所有执行器发送任务调度，请求中携带分片参数。）</p><p>分片广播需要两个分片参数才能确保执行器在执行过程中执行任务不重复</p><ul><li>执行器的分片序号</li><li>执行器的总数</li></ul><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240730095826808.png" alt="image-20240730095826808" style="zoom:33%;"><h2 id="day07"><a href="#day07" class="headerlink" title="day07"></a>day07</h2><p>视频处理-分布式任务调度</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240730102936132.png" alt="image-20240730102936132" style="zoom:33%;"><p>通过作业分片方案保证了执行器之间查询到不重复的任务，如果一个执行器在处理一个视频还没有完成，此时调度中心又一次请求调度，为了不重复处理同一个视频该怎么办？</p><ul><li>配置调度过期策略<ul><li>忽略</li><li>立即执行一次</li></ul></li><li>阻塞处理策略<ul><li>单机串行</li><li>丢弃后续调度</li><li>覆盖之前调度</li></ul></li></ul><p>幂等性：它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果。</p><p>在执行器接收调度请求去执行视频处理任务时要实现视频处理的<strong>幂等性</strong>，要有办法去判断该视频是否处理完成，如果正在处理中或处理完则不再处理。这里我们在数据库视频处理表中添加处理状态字段，视频处理完成更新状态为完成，执行视频处理前判断状态是否完成，如果完成则不再处理。</p><h3 id="查询待处理任务"><a href="#查询待处理任务" class="headerlink" title="查询待处理任务"></a>查询待处理任务</h3><p>如何保证查询到的处理视频记录不重复？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>关键在于这个<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> media_process t <span class="keyword">where</span> t.id <span class="operator">%</span> #&#123;shardTotal&#125; <span class="operator">=</span> #&#123;shardIndex&#125; <span class="keyword">and</span> (t.status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> t.status <span class="operator">=</span> <span class="string">&#x27;3</span></span><br></pre></td></tr></table></figure><h3 id="开始任务执行"><a href="#开始任务执行" class="headerlink" title="开始任务执行"></a>开始任务执行</h3><p>前边分析了保证任务不重复执行的方案，理论上每个执行器分到的任务是不重复的，但是当在执行器弹性扩容时无法绝对避免任务不重复执行，比如：原来有四个执行器正在执行任务，由于网络问题原有的0、1号执行器无法与调度中心通信，调度中心就会对执行器重新编号，原来的3、4执行器可能就会执行和0、1号执行器相同的任务。</p><p>使用多个执行器不能<strong>绝对避免</strong>执行同一任务，如何？<strong>使用锁</strong></p><p>由于synchronized只能保证同一个虚拟机中多个线程去争抢锁—-&gt;<strong>因此使用分布式锁</strong></p><p>虚拟机都去抢占同一个锁，锁是一个单独的程序提供加锁、解锁服务。</p><p><strong>该锁已不属于某个虚拟机，而是分布式部署，由多个虚拟机所共享，这种锁叫分布式锁。</strong></p><p>实现分布式锁的方法：</p><ul><li>基于数据库实现分布式锁：主键的唯一性</li><li>基于redis实现分布式锁，如SETNX</li><li>使用zookeeper实现</li></ul><p><strong>基于数据库实现分布式锁</strong>（使用了乐观锁的方式实现）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> t1.data1 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>,t1.version<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> <span class="keyword">where</span> t1.version<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240730170123981.png" alt="image-20240730170123981" style="zoom:33%;"><h3 id="更新任务状态"><a href="#更新任务状态" class="headerlink" title="更新任务状态"></a>更新任务状态</h3><h3 id="视频处理-1"><a href="#视频处理-1" class="headerlink" title="视频处理"></a>视频处理</h3><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240730201842690.png" alt="image-20240730201842690" style="zoom:33%;"><p>好几个方法之前在实现类中抽取过，但都没有提取到接口，在VideoTask中无法注入使用，因此要将他们呢提取为借口才行，如addMediaFilesToMinIO()和downloadFileFromMinIO()</p><p>线程池的线程的数量最多时cpu的核心数</p><p>所有逻辑写完后注意一个点，下面代码会启动size个线程，会瞬间启动完成，也就是说videoJobHandler()方法会立即执行完成，任务逻辑是在线程中执行的，不再videoJobHandler()中执行，该方法只负责启动线程，启动完了纠结数据。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240730210225259.png" alt="image-20240730210225259" style="zoom:33%;"><p>我们想要所有线程把他们的方法执行完后videoJobHandler方法才结束，也就是说我们想要所有任务执行完后才会进行下次调度，因此我们使用计数器</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240730210701879.png" alt="image-20240730210701879" style="zoom:33%;"><p>为了防止代码中间出现异常导致计数器不减1，使用try-finally,正常情况到0就解除阻塞</p><p>但还得要保底情况，我们需要<strong>指定最大限制的等待时间，阻塞最多等待一定的时间后就接触阻塞</strong></p><h4 id="其他问题：有三个需要自己实现"><a href="#其他问题：有三个需要自己实现" class="headerlink" title="其他问题：有三个需要自己实现"></a>其他问题：有三个需要自己实现</h4><ul><li>任务补偿机制</li><li>达到最大失败次数</li><li>分块文件清理问题</li></ul><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731092844419.png" alt="image-20240731092844419" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731093259387.png" alt="image-20240731093259387" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731094237410.png" alt="image-20240731094237410" style="zoom:33%;"><h3 id="绑定媒资"><a href="#绑定媒资" class="headerlink" title="绑定媒资"></a>绑定媒资</h3><p><strong>将视频和课程计划进行绑定</strong>，需要teachplan_media表，这个操作在<strong>内容管理模块不再媒资</strong></p><p>接口实现：</p><p>先删除原有记录–&gt;再添加新记录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(BindTeachplanMediaDto bindTeachplanMediaDto)</span></span><br></pre></td></tr></table></figure><h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731105430184.png" alt="image-20240731105430184" style="zoom:33%;"><p>根据接口定义实现解除绑定功能。</p><p>点击已经绑定的视频名称即可解除绑定。</p><h3 id="课程分布"><a href="#课程分布" class="headerlink" title="课程分布"></a>课程分布</h3><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731102847620.png" alt="image-20240731102847620" style="zoom:33%;"><h4 id="课程预览"><a href="#课程预览" class="headerlink" title="课程预览"></a>课程预览</h4><p>作为课程制作方即教学机构，在课程发布前通过课程预览功能可以看到课程发布后的效果，哪里的课程信息存在问题方便查看，及时修改</p><p>课程预览就是把课程的相关信息进行整合，在课程详情界面进行展示，通过课程预览页面查看信息是否存在问题。</p><p>我们需要在服务端生成页面，使用模版引擎FreeMarker，<strong>属于内容管理模块</strong>，模版引擎就是在服务端渲染生成页面，需要有模版和数据</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">freemarker配置信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span>   <span class="comment">#关闭模板缓存，方便测试</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">template_update_delay:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span>   <span class="comment">#页面模板后缀名</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">template-loader-path:</span> <span class="string">classpath:/templates/</span>   <span class="comment">#页面模板位置(默认为 classpath:/templates/)</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="comment">#关闭项目中的静态资源映射(static、resources文件夹下的资源)</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>课程预览就是把课程的相关信息进行整合，在课程预览界面进行展示，课程预览界面与课程发布的课程详情界面一致。项目采用模板引擎技术实现课程预览界面。</p><ul><li>配置nginx老出现403forbidden，如下几行代码解决</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod o+x /Users</span><br><span class="line">sudo chmod o+x /Users/qh</span><br><span class="line">sudo chmod o+x /Users/qh/Desktop</span><br><span class="line">sudo chmod o+x /Users/qh/Desktop/Project</span><br><span class="line">sudo chmod o+x /Users/qh/Desktop/Project/xc-ui-pc-static-portal</span><br></pre></td></tr></table></figure><ul><li>server_name较长需要引入server_names_hash_bucket_size 128;</li></ul><h2 id="day08"><a href="#day08" class="headerlink" title="day08"></a>day08</h2><p>之前点一下按钮需要返回json，现在需要返回页面</p><p>@RestController响应json，@Controller响应页面</p><h3 id="定义课程预览接口"><a href="#定义课程预览接口" class="headerlink" title="定义课程预览接口"></a>定义课程预览接口</h3><p>课程预览接口虽然可以正常访问，<strong>但是页面没有样式</strong>，查看浏览器请求记录，发现图片、样式无法正常访问。</p><p>这些静态资源全在门户下，我们需要由Nginx反向代理访问课程预览接口，通过门户的URL去访问课程预览。因此配置反向代理，通过nginx访问这个地址<a href="http://localhost:63040/content/coursepreview/74">http://localhost:63040/content/coursepreview/74</a> </p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731205435105.png" alt="image-20240731205435105" style="zoom:25%;"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #后台网关</span><br><span class="line"> #所有以api开头的地址全都进入网关</span><br><span class="line">upstream gatewayserver&#123;</span><br><span class="line">  server 127.0.0.1:63010 weight=10;</span><br><span class="line">&#125; </span><br><span class="line">server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  www.51xuecheng.cn localhost;</span><br><span class="line">      ....</span><br><span class="line">      #api</span><br><span class="line">      location /api/ &#123;</span><br><span class="line">              proxy_pass http://gatewayserver/;</span><br><span class="line">      &#125; </span><br><span class="line">      ....</span><br></pre></td></tr></table></figure><p>nginx配置网关，由网关将请求转发到内容管理服务，否则就得一个一个通过upstream配置微服务</p><p>启动网关微服务后</p><p>通过域名访问（<strong>课程预览链接</strong>）<a href="http://www.51xuecheng.cn/api/content/coursepreview/74">http://www.51xuecheng.cn/api/content/coursepreview/74</a> 可以解析上面域名中的样式文件。</p><p>具体流程就是：<strong>请求课程预览页面-》nginx-》网关-》内容管理服务-》</strong>返回页面-》浏览器加载解析-》请求静态资源-》nginx-》响应静态资-》渲染页面样式</p><h4 id="接口开发"><a href="#接口开发" class="headerlink" title="接口开发"></a>接口开发</h4><p>此时课程预览页面全是静态数据，我们要进行接口开发，从数据库中查数据</p><p>课程预览就是把课程基本信息、营销信息、课程计划、这三个之前有dto也有进行了接口实现</p><p>师资（这里没有做）等课程的相关信息进行整合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoursePreviewDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 课程基本计划、课程营销信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CourseBaseInfoDto courseBaseInfoDto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 课程计划信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;TeachplanDto&gt; teachplans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 师资信息暂时不加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口完善"><a href="#接口完善" class="headerlink" title="接口完善"></a>接口完善</h4><h4 id="前后端联调-1"><a href="#前后端联调-1" class="headerlink" title="前后端联调"></a>前后端联调</h4><p>我们也要改变，前端访问nginx再到网关再到微服务，因为课程预览只有通过域名访问才有样式</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240731201323301.png" alt="image-20240731201323301" style="zoom:33%;"><h4 id="编写模版"><a href="#编写模版" class="headerlink" title="编写模版"></a>编写模版</h4><p>成功点击预览，会出现新的预览页面，但数据还是静态的，现在需要编写模版修改数据</p><h4 id="视频播放页面接口"><a href="#视频播放页面接口" class="headerlink" title="视频播放页面接口"></a>视频播放页面接口</h4><p>需要两个接口，需要从nginx调用，这两个接口以后不用登录也能用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#openapi</span></span><br><span class="line">location /open/content/ &#123;</span><br><span class="line">        proxy_pass http://gatewayserver/content/open/;</span><br><span class="line">&#125; </span><br><span class="line">location /open/media/ &#123;</span><br><span class="line">        proxy_pass http://gatewayserver/media/open/;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>一个获取课程信息接口–内容管理微服务</p><p>一个获取视频地址接口–媒资管理微服务</p><p>这里加载不了avi视频，只能选择mp4的才能播放</p><h3 id="课程审核"><a href="#课程审核" class="headerlink" title="课程审核"></a>课程审核</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>流程复杂的话使用工作流引擎，一套框架专门做工作流</p><p>这里不复杂，定一个状态字段用来控制课程审核状态</p><p><strong>需求分析就两点一个业务模型一个数据模型</strong></p><p>如何控制课程审核通过才可以发布课程呢？</p><p>在课程基本表course_base表设置课程审核状态字段，包括：未提交、已提交(未审核)、审核通过、审核不通过。</p><p>课程审核功能涉及教学机构提交审核，运营人员进行课程审核。在课堂上我们仅实现教学机构提交审核功能，课程审核的结果通过手动修改数据库来实现。</p><p>提交审核：<strong>提交审核将信息写入课程预发布表</strong></p><p>课程预发布表：用来存储<strong>课程审核</strong>的信息<strong>审核通过后</strong>这个信息就作为<strong>课程发布的信息</strong>复制到课程发布表</p><h4 id="接口定义、开发、测试"><a href="#接口定义、开发、测试" class="headerlink" title="接口定义、开发、测试"></a>接口定义、开发、测试</h4><p>这三个信息需要json格式，<strong>这里与预览接口一样没有插入教师信息</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240801104346470.png" alt="image-20240801104346470" style="zoom:33%;"><p>这里要注意在向课程预发布表中插入数据时，不能只插入，因为他的主键字段不是自增的是从就是课程id，有可能已经存在，因此不能insert直接，在存在时需要update</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询预发布表，如果有记录则更新，没有则插入</span></span><br><span class="line">        <span class="type">CoursePublishPre</span> <span class="variable">coursePublishPreObj</span> <span class="operator">=</span> coursePublishPreMapper.selectById(courseId);</span><br><span class="line">        <span class="keyword">if</span> (coursePublishPreObj==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            coursePublishPreMapper.insert(coursePublishPre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        coursePublishPreMapper.updateById(coursePublishPre);</span><br></pre></td></tr></table></figure><p>最终会向两个地方插入数据</p><ul><li>预发布表插入一条记录</li><li>更新课程基本信息表的发布状态为已提交</li></ul><p>笑死了在提交审核的时候，插入课程预发布表时tags字段的内容不能太长否则会报错，例如<strong>JAVA8&#x2F;9&#x2F;10新特性讲解——修改00</strong>这个课程(course_id&#x3D;1)tags很长就不行</p><h4 id="手动审核："><a href="#手动审核：" class="headerlink" title="手动审核："></a>手动审核：</h4><p>审核通过需手动修改数据库：</p><p>1、修改课程预发布表的状态为审核通过202004。</p><p>2、修改课程基本表的审核状态为审核通过202004。</p><h3 id="课程发布"><a href="#课程发布" class="headerlink" title="课程发布"></a>课程发布</h3><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>审核完成后，开始课程发布</p><p>页面不能再从数据库中拿数据，提高课程查询速度， 将课程信息缓存到redis中，插入到elasticsearch索引中</p><p>预览页面在预览时可以通过服务端渲染的，但是发布之后不能在通过服务器渲染的，不能在通过tomcat服务器了，将预览页面生成html静态页面通过nginx来请求查看，将该页面放到minio中（因为这里用的不是前后端分离技术，不这么搞tomcat就给前端发静态页面，那么不是性能就降低了咩？）</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>本地事务：使用服务自己的数据库来控制事务</p><p>分布式事务：通过与不同的服务进行网络通信去完成事务称之为<strong>分布式事务</strong></p><p>就是想做一件事需要多个服务网络交互来完成</p><p><strong>控制分布式事务首先要理解CAP理论</strong>，理解如何去控制？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:Consistency,一致性,一致性是指用户不管访问哪一个结点拿到的数据都是最新的，比如查询小明的信息，不能出现在数据没有改变的情况下两次查询结果不一样。</span><br><span class="line">A:Availability,可用性,可用性是指任何时候查询用户信息都可以查询到结果，但不保证查询到最新的数据。</span><br><span class="line">P:Partition tolerance,分区容忍性,不同地点存在网络分区 但是需要一定的分区容忍性 也就是不能因为网络故障导致网络不可用</span><br></pre></td></tr></table></figure><p>在分布式系统下如果存在分布式事务CAP只能满足两种<strong>CP(强调一致性)<strong>或</strong>AP(强调可用性，数据可用但是可能有一段时间不一致)</strong></p><p>项目中AP场景更多，强调可用性</p><p>基于AP提出BASE理论：Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)</p><p>选用AP，通过使用<strong>任务调度</strong>或消息队列的方法来见数据同步到redis、搜索引擎、minio</p><p>最终选择<strong>本地消息表+任务调度，</strong>最终实现分布式事务的最终一致性（跟minio分布式调度转码过程类似，需要一个mediaprocess表和mediaprocesshistory表，一旦视频转码成功将他从mediaprocess中删除放到mediaprocesshistory）</p><p>建立一张消息表用来存储需要需要发布的课程信息，数据同步完成后就删除</p><h4 id="课程发布接口"><a href="#课程发布接口" class="headerlink" title="课程发布接口"></a>课程发布接口</h4><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240801160316884.png" alt="image-20240801160316884" style="zoom:33%;"><p>查询预发布表–&gt;向课程发布表写数据–&gt;向消息表写数据（通过SDK工具包向消息表写数据）–&gt;将预发布表数据删除</p><p>针对<strong>向消息表写数据</strong>步骤。  使用<strong>消息SDk</strong>，不去抽取为一个微服务，而且定义微服务要写很多的接口和实现代码，这里的新需求只是消息表的增删改查，所以SDK工具包更合适，只需要项目引入就可以使用</p><p><strong>本项目确定将对消息表相关的处理做成一个SDK组件供各微服务使用</strong>，将消息表的增删改查全部封装到SDK中，SDK中不实现任务的逻辑，只提供一个抽象方法由具体的执行任务方法去实现</p><p>这里是信息同步类任务，即使任务重复执行也没有关系（不想之前转码重复的话需要大量时间，这里就算重复了也没事不费时间所以不用加锁的方式），不再使用抢占任务的方式保证任务不重复执行。</p><p>测试中发现还有个bug就是在coursebase表中有个status状态控制已发布和未发布状态203001表示未发布，此时前端可以点击发布，已发布状态为203002此时前端不能点击，<strong>发布成功后此状态不会变化，也就是发布后还能再点击发布</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240801173124375.png" alt="image-20240801173124375" style="zoom:33%;"><h4 id="课程发布任务处理"><a href="#课程发布任务处理" class="headerlink" title="课程发布任务处理"></a>课程发布任务处理</h4><p>关于sdk模块包扫描问题，其实启动类所在包就是com.xuecheng前面说过，所以肯定能扫到sdk包的，sdk也有com.xuecheng</p><p><strong>下面进行扫描消息，启动任务</strong>，红框代码全都封装到sdk里面</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240801203634413.png" alt="image-20240801203634413" style="zoom:33%;"><p>对消息表进行处理包括：新增消息表、扫描消息表、更新消息表（需要修改state1、2、3、4字段，实现幂等性）、删除消息表</p><p><strong>在内容管理服务添加消息处理sdk的依赖即可使用它，实现sdk中的MessageProcessAbstract类，重写execte方法，该方法就是具体执行任务的逻辑</strong>，扫描到任务后一个任务一个任务的通过多线程执行execute方法，process是执行任务的具体方法</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240801204539494.png" alt="image-20240801204539494" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240801205440761.png" alt="image-20240801205440761" style="zoom:33%;"><p>这个是多线程任务，你不知道传进来的时候是不是还是目前数据库的内容</p><p>防止你在调用的过程中其他线程又对数据进行了更改虽然增加了数据库Io但是能够减少重复操作的频率</p><p>减少重复执行概率啊，万一2个线程同时拿到同一个message，然后另一个线程执行完了，你再走业务不查最新的，是不是要重复执行了</p><p>business_key字段，消息类型代码，三个字段想写那个写那个，例如发布任务，就把课程id写进去，写第一个第二个第三个字段都可以</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240813093029577.png" alt="image-20240813093029577"></p><h2 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h2><p>完善day08中<strong>课程静态话上传到minio</strong>和向<strong>elasticsearch写索引数据</strong>，缓存redis后面会讲</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240802141556536.png" alt="image-20240802141556536"></p><h3 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h3><p>课程信息生成后页面是不会经常变化的</p><p>根据课程发布的操作流程，执行课程发布后要将课程详情信息页面静态化，生成html页面上传至文件系统。</p><p><strong>什么是页面静态化？</strong></p><p>课程预览功能通过模板引擎技术在页面模板中填充数据，生成html页面，这个过程是当客户端请求服务器时服务器才开始渲染生成html页面，最后响应给浏览器，服务端渲染的并发能力是有限的。</p><p>页面静态化则强调将生成html页面的过程提前，提前使用模板引擎技术生成html页面，当客户端请求时直接请求html页面，由于是静态页面可以使用nginx、apache等高性能的web服务器，并发性能高。</p><p><strong>什么时候能用页面静态化技术？</strong></p><p>当数据变化不频繁，一旦生成静态页面很长一段时间内很少变化，此时可以使用页面静态化。因为如果数据变化频繁，一旦改变就需要重新生成静态页面，导致维护静态页面的工作量很大。</p><p>根据课程发布的业务需求，虽然课程发布后仍可以修改课程信息，但需要经过课程审核，且修改频度不大，所以适合使用页面静态化。</p><h3 id="静态化测试"><a href="#静态化测试" class="headerlink" title="静态化测试"></a>静态化测试</h3><p>在之前课程预览时是在content-api工程点击预览按钮通过freemarker进行服务端渲染生成页面的，现在是一个任务，这个任务要进行页面静态话，这个任务写在service工程，所以依赖加入到service工程</p><h3 id="上传文件测试"><a href="#上传文件测试" class="headerlink" title="上传文件测试"></a>上传文件测试</h3><p><strong>请求媒资服务，由媒资服务将文件上传至minio</strong>，内容管理服务掉媒资服务</p><p>静态化生成文件后需要上传至分布式文件系统，根据微服务的职责划分，媒资管理服务负责维护文件系统中的文件，所以内容管理服务对页面静态化生成html文件需要调用媒资管理服务的上传文件接口。</p><p>微服务之间难免会存在远程调用，在Spring Cloud中可以使用Feign进行远程调用，</p><p>服务注册到nacos中作用：能够让网关获取微服务相关信息（网关从Nacos读取服务列表，包括服务名称、服务地址等）、以及各个微服务之间的相互调用</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240802170354348.png" alt="image-20240802170354348" style="zoom:25%;"><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">原来微服务之间可能传递的是数据，但现在远程调用需要传文件，使用下面这个让他支持multipart传参数</span><br><span class="line"><span class="comment">&lt;!--feign支持Multipart格式传参--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">//因为要feigin要调用service需要通过服务注册中心拿到这个服务的实例</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要在启动类上加入@EnableFeignClients(basePackages&#x3D;{“com.xuecheng.content.feignclient”})是的扫描到刚才的feighclient才能生成代理对象</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240802172713447.png" alt="image-20240802172713447" style="zoom:33%;"><p>这里远程调用测试的时候老找不到media-api服务找不到，我们得去test中的配置文件yml中也要添加</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">discovery:</span> <span class="comment">#注册到nacos中 服务注册相关配置</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev_xcplus</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">xuecheng-plus-project</span></span><br></pre></td></tr></table></figure><p>在通过远程调用将静态test.html上传到minio后，通过<a href="http://172.24.40.60:9000/mediafiles/course/test.html%E8%AE%BF%E9%97%AE%E5%8F%91%E7%8E%B0%E6%B2%A1%E6%9C%89%E6%A0%B7%E5%BC%8F">http://172.24.40.60:9000/mediafiles/course/test.html访问发现没有样式</a></p><p>我们通过<a href="http://file.51xuecheng.cn/mediafiles/course/test.html%E4%B9%9F%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%EF%BC%8C%E5%9B%A0%E4%B8%BAfile.51xuecheng.cn%E8%99%9A%E6%8B%9F%E5%99%A8%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%E5%9C%B0%E5%9D%80">http://file.51xuecheng.cn/mediafiles/course/test.html也访问不到，因为file.51xuecheng.cn虚拟器中没有配置样式地址</a></p><p><strong>主站虚拟服务器下才配置了样式地址</strong></p><p>因此要想获得样式得通过主站访问，也就是以域名<a href="http://www.51xuecheng.cn/%E5%BC%80%E5%A4%B4%E6%9D%A5%E8%AE%BF%E9%97%AE">www.51xuecheng.cn/开头来访问</a></p><p>我们在主站下配置代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /course/ &#123;  </span><br><span class="line">        proxy_pass http://fileserver/mediafiles/course/;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>此时通过<a href="http://www.51xuecheng.cn/course/test.html%E8%AE%BF%E9%97%AE%E5%B0%B1%E8%83%BD%E5%8A%A0%E8%BD%BD%E5%87%BA%E6%A0%B7%E5%BC%8F">http://www.51xuecheng.cn/course/test.html访问就能加载出样式</a></p><h3 id="熔断降级处理"><a href="#熔断降级处理" class="headerlink" title="熔断降级处理"></a>熔断降级处理</h3><p>feign远程调用涉及熔断，我们需要在配置文件从nacos加载feign的配置文件（开启feign熔断保护）</p><p><strong>如何解决由于微服务异常引起的雪崩效应呢？可以采用熔断、降级的方法去解决。</strong></p><p>熔断是当下游服务（被调用的服务）异常时一种保护系统的手段，降级是熔断后上游服务（调用者）处理熔断的方法。</p><p>具体流程：</p><p>项目使用Hystrix框架实现熔断、降级处理，在feign-dev.yaml中配置。</p><p>开启Feign熔断保护–&gt;设置熔断的超时时间，为了防止一次处理时间较长触发熔断这里还需要设置请求和连接的超时时间–&gt;定义降级逻辑（fallback、fallbackFactory）</p><p>fallback：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个fallback类MediaServiceClientFallback，此类实现了MediaServiceClient接口。</span></span><br><span class="line"><span class="comment">//第一种方法无法取出熔断所抛出的异常</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;,configuration = MultipartSupportConfig.class,fallback = MediaServiceClientFallback.class)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/media&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaServiceClient</span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>fallbackFactory ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;,configuration = MultipartSupportConfig.class,fallbackFactory = MediaServiceClientFallbackFactory.class)</span></span><br><span class="line"><span class="comment">//第二种方法定义MediaServiceClientFallbackFactory 可以解决这个问题。</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaServiceClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;MediaServiceClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MediaServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MediaServiceClient</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile upload, String objectName)</span> &#123;</span><br><span class="line">                <span class="comment">//降级方法</span></span><br><span class="line">                log.debug(<span class="string">&quot;调用媒资管理服务上传文件时发生熔断，异常信息:&#123;&#125;&quot;</span>,throwable.toString(),throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程静态化开发"><a href="#课程静态化开发" class="headerlink" title="课程静态化开发"></a>课程静态化开发</h3><p>两部分：生成课程静态化页面，上传静态页面到文件系统</p><p>在课程发布的service编写这两部分内容，最后通过消息去调度执行。</p><p>之前已经写过这两部分的测试方法了，这里拿过来改改就行 </p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240803161333537.png" alt="image-20240803161333537"></p><p>气死了，一下午bug</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240803192801068.png" alt="image-20240803192801068"></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240803214529138.png" alt="image-20240803214529138" style="zoom:33%;"><h3 id="课程搜索"><a href="#课程搜索" class="headerlink" title="课程搜索"></a>课程搜索</h3><p><strong>本项目使用elasticsearch作为索引及搜索服务。</strong>—得学学</p><p>传统方法：先找文章再找词</p><p>全文检索方法：先找词再找文章，本项目课程搜索支持全文检索</p><p>课程搜索模块包括两部分：<strong>课程索引、课程搜索。</strong></p><ul><li><p>课程索引是将课程信息建立索引。</p></li><li><p>课程搜索是通过前端网页，通过关键字等条件去搜索课程。</p></li></ul><p>在MySQL中，<code>CREATE SCHEMA</code>创建了一个数据库，这是因为<code>CREATE SCHEMA</code>是<code>CREATE DATABASE</code>的同义词。 换句话说，你可以使用<code>CREATE SCHEMA</code>或者<code>CREATE DATABASE</code>来创建一个数据库。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240803201122541.png" alt="image-20240803201122541" style="zoom:33%;"><h4 id="课程信息索引同步"><a href="#课程信息索引同步" class="headerlink" title="课程信息索引同步"></a>课程信息索引同步</h4><p>为了满足实时性的高要求：两种方案</p><ul><li>手动编写同步代码，也就是在添加课程到数据库的同时，将它夹到es索引中去，但是代码耦合度高</li><li>使用canal中间件</li></ul><p>实时性不高：三种方案</p><ul><li>MQ：需要保证消息可靠性</li><li>Logstash</li><li>任务调度：<strong>本文选用这个</strong>，<strong>内容管理服务远程调用搜索服务的写索引接口</strong></li></ul><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240803214504775.png" alt="image-20240803214504775" style="zoom:33%;"><p>记得才content-api中添加search服务的配置文件依赖，找了一会bug</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240803215807106.png" alt="image-20240803215807106"></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804093702874.png" alt="image-20240804093702874"></p><h3 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h3><p><strong>授权就是登录成功后，访问我们的微服务是否有权限</strong></p><p>统一认证入口（登陆页面）–&gt;单点登录（用户只需要认证一次，便可以在多个拥有访问权限的系统中访问）–&gt;第三方认证（微信扫码登登录）</p><p><strong>从一个空白的springboot工程实现一个具有认证授权的认证服务</strong></p><p>复制WebSecurityConfig.java有报错，如下解决</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804103306433.png" alt="image-20240804103306433" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804103848560.png" alt="image-20240804103848560" style="zoom:33%;"><p>过滤器是在请求到达之前的预处理或者后处理，拦截器是对方法调用的前后或者抛出异常时的处理，监听器是监听特定事件执行相应操作</p><p>SecurityContextHolder.getContext()底层就是使用了threadlocal</p><h4 id="Spring-Security执行流程"><a href="#Spring-Security执行流程" class="headerlink" title="Spring Security执行流程"></a>Spring Security执行流程</h4><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804104557504.png" alt="image-20240804104557504"></p><h4 id="OAuth2协议（用于第三方认证）"><a href="#OAuth2协议（用于第三方认证）" class="headerlink" title="OAuth2协议（用于第三方认证）"></a>OAuth2协议（用于第三方认证）</h4><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804111502596.png" alt="image-20240804111502596" style="zoom:33%;"><p>OAuth2在本项目的应用</p><p>1、学成在线访问第三方系统的资源。</p><p>本项目要接入微信扫码登录所以本项目要使用OAuth2协议访问微信中的用户信息。</p><p>2、外部系统访问学成在线的资源  。</p><p>同样当第三方系统想要访问学成在线网站的资源也可以基于OAuth2协议。</p><p>3、学成在线前端（客户端） 访问学成在线微服务的资源。<strong>（单点登录）</strong></p><p>本项目是前后端分离架构，前端访问微服务资源也可以基于OAuth2协议进行认证。</p><h4 id="OAuth2授权模式"><a href="#OAuth2授权模式" class="headerlink" title="OAuth2授权模式"></a>OAuth2授权模式</h4><p>Spring Security支持OAuth2认证，OAuth2提供授权码模式、密码模式、简化模式、客户端模式等四种授权模式</p><ul><li>授权码模式：</li></ul><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804114615809.png" alt="image-20240804114615809" style="zoom:25%;"><p>还以黑马网站微信扫码登录为例进行说明：</p><p>1、用户打开浏览器。</p><p>2、通过浏览器访问客户端即黑马网站。</p><p>3、用户通过浏览器向认证服务请求授权，请求授权时会携带客户端的URL，此URL为下发授权码的重定向地址。</p><p>4、认证服务向资源拥有者返回授权页面。</p><p>5、资源拥有者亲自授权同意。</p><p>6、通过浏览器向认证服务发送授权同意。</p><p>7、认证服务向客户端地址重定向并携带授权码。</p><p>8、客户端即黑马网站收到授权码。</p><p>9、客户端携带授权码向认证服务申请令牌。</p><p>10、认证服务向客户端颁发令牌。</p><ul><li>密码模式：直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。</li></ul><h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><h3 id="jwt令牌"><a href="#jwt令牌" class="headerlink" title="jwt令牌"></a>jwt令牌</h3><p>Json Web Token，可以使资源服务自己校验令牌的合法性，由三部分构成Header、Payload、Signature</p><ul><li><p>Header：头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）</p></li><li><p>Payload：<strong>存储一下可以公开出去的用户信息，如用户头像</strong></p><p>第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的信息字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。</p><p>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</p></li><li><p>第三部分是签名，此部分用于防止jwt内容被篡改。</p><p>  这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明的签名算法进行签名。</p></li></ul><p>修改TokenConfig配置将普通令牌转换为jwt令牌</p><h4 id="携带令牌访问资源服务"><a href="#携带令牌访问资源服务" class="headerlink" title="携带令牌访问资源服务"></a>携带令牌访问资源服务</h4><p>拿到了jwt令牌下一步就要携带令牌去访问资源服务中的资源，本项目各个微服务就是资源服务，比如：内容管理服务，客户端申请到jwt令牌，携带jwt去内容管理服务查询课程信息，此时内容管理服务要对jwt进行校验，只有jwt合法才可以继续访问。如下图：</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804164103259.png" alt="image-20240804164103259" style="zoom:25%;"><p>增加依赖，导入两个配置文件，使得springSecurity管控内容管理服务</p><p>在这里注意三点，微服务密钥与认证服务相同，资源名也要相同，在配置类当中设置要管控的url</p><h4 id="测试获取用户身份"><a href="#测试获取用户身份" class="headerlink" title="测试获取用户身份"></a>测试获取用户身份</h4><p>SecurityContextHolder.getContext()底层就是使用了threadlocal</p><h4 id="网关认证"><a href="#网关认证" class="headerlink" title="网关认证"></a>网关认证</h4><p>微服务中检验令牌合法性 可以通过网关 这样只需要网关一个微服务进行校验</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804174339984.png" alt="image-20240804174339984" style="zoom:33%;"><p>所有访问微服务的请求都要经过网关，在网关进行用户身份的认证可以将很多非法的请求拦截到微服务以外，这叫做网关认证。<strong>注意网关不要拦截认证服务因为此时没有token呢，得先去获取token</strong></p><p>三个作用：路由转发、认证（校验jwt令牌的合法性）、白名单维护（针对不用认证的URL全部放行）</p><p><strong>网关进行认证，但网关进行授权不方便，微服务负责授权</strong></p><p>网关，认证jwt令牌是否合法，是不是伪造的，是不是真的用户。正常用户就可以放行了，但是具体能不能访问到这个资源，要看微服务</p><p><strong>在微服务中要放行所有请求，这里注释之前在content中配置拦截器</strong>，微服务不需要再进行校验了</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804174744147.png" alt="image-20240804174744147" style="zoom:33%;"><h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><h4 id="连接数据库认证"><a href="#连接数据库认证" class="headerlink" title="连接数据库认证"></a>连接数据库认证</h4><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804202600032.png" alt="image-20240804202600032" style="zoom:33%;"><p>自定义一个实现类去实现由SpringSecirity的UserDetailsService接口</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804202949479.png" alt="image-20240804202949479"></p><p>我们只要实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可,框架调用loadUserByUsername()方法拿到用户信息之后是如何执行的</p><p>由于数据库中密码不是明文，因此需要将明文加密方式改为密文加密方式，密钥也要改为加密后的</p><h4 id="扩展用户身份信息"><a href="#扩展用户身份信息" class="headerlink" title="扩展用户身份信息"></a>扩展用户身份信息</h4><p>原来只有账号太少了不够用</p><p>方法：</p><ul><li>第一是可以扩展UserDetails，使之包括更多的自定义属性</li><li>第二也可以扩展username的内容 ，比如存入json数据内容作为username的内容。<strong>（简单采用）</strong></li></ul><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240804211612200.png" alt="image-20240804211612200"></p><h4 id="资源服务获取用户身份"><a href="#资源服务获取用户身份" class="headerlink" title="资源服务获取用户身份"></a>资源服务获取用户身份</h4><p>使用工具类SecurityUtil将获取到的字符串转为对象，SecurityUtil中存在一个内部类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XcUser--内部类，与获取到的用户信息对应，这个类其实就是auth认证服务中的po类对应用户的信息，这里为了避免依赖auth认证服务，所以单独定义一个类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">XcUser</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure><h3 id="统一认证入口"><a href="#统一认证入口" class="headerlink" title="统一认证入口"></a>统一认证入口</h3><p>根据不同的方式进来有不同的策略，<strong>策略模式</strong></p><p>统一认证请求的数据</p><p>我靠，这里的注入方式看懵我了，得再复习复习</p><p>原来是只要返回UserDetails，框架会自动校验密码，但是不是所有的认证都要校验密码，例如手机验证码，由于原来的DaoAuthenticationProvider 会进行密码校验，现在重新定义DaoAuthenticationProviderCustom类，重写类的additionalAuthenticationChecks方法。</p><p>有校验密码，<strong>不想要就重写，空着就行</strong>，就是后面有校验密码也不再使用框架来校验了，自己另外写方法进行校验，也就是additionalAuthenticationChecks方法置为空，方法体为空</p><p>还得WebSecurityConfig注入新的authenticationProvider，告诉框架使用自己重写的authenticationProvider</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240805104634094.png" alt="image-20240805104634094" style="zoom:33%;"><p>有了这些认证参数我们可以定义一个认证Service接口去进行各种方式的认证。</p><p>定义用户信息，为了扩展性让它继承XcUser</p><p>我靠由于可能存在多种认证方式，这里在获取不同认证方式的时候，直接注入了IOC容器，然后根据bean的名字去找我们所需要对应实现类的对象，我靠惊了</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240805110455829.png" alt="image-20240805110455829"></p><h3 id="验证码服务"><a href="#验证码服务" class="headerlink" title="验证码服务"></a>验证码服务</h3><p>验证码作为一个独立的微服务，本项目创建单独的验证码服务为各业务提供验证码的生成、校验等服务。</p><p>虚拟机redis连不上md，直接用mac本地redis 没有密码，nacos中yaml如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span></span><br><span class="line">    <span class="comment">#redisson:</span></span><br><span class="line">      <span class="comment">#配置文件目录</span></span><br><span class="line">      <span class="comment">#config: classpath:singleServerConfig.yaml</span></span><br></pre></td></tr></table></figure><p>验证码服务如何生成并校验验证码？</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240805135747502.png" alt="image-20240805135747502" style="zoom:33%;"><h3 id="账号密码认证"><a href="#账号密码认证" class="headerlink" title="账号密码认证"></a>账号密码认证</h3><p>认证服务认证成功后，会颁发jwt令牌，存入cookie中</p><p>令牌存在客户端cookie，当要去访问微服务时，前端会将令牌加入到http的头信息中携带到网关，由网关转发到微服务</p><p>退出就是吧cookie清除</p><p>验证码校验是远程调用，即认证服务调用验证码服务进行验证码校验，需要编写Fieignclient接口</p><h3 id="微信扫码登录"><a href="#微信扫码登录" class="headerlink" title="微信扫码登录"></a>微信扫码登录</h3><p><a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html接口地址</a></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806194623414.png" alt="image-20240806194623414" style="zoom:25%;"><p>需要对接第三方接口</p><p>微信重定向到某个地址包含授权码</p><p>拿到用户信息保存到数据后，重定向到我们的认证接口</p><p>远程调用和第三方进行的话使用在启动类配置<strong>restTemplate</strong>，和微服务之间需要使用feign</p><p><strong>具体流程：</strong>这些所有的链接格式都是springsecurity固定好的，为什么是auth&#x2F;token？固定好的都是</p><p>1.授权后获得授权码code</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806165851602.png" alt="image-20240806165851602" style="zoom:33%;"><ol start="2"><li>通过appid、secret以及code请求微信：申请令牌、使用令牌查询用户信息、将用户信息写入数据库</li></ol><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806170155341.png" alt="image-20240806170155341" style="zoom:33%;"><p>3.重定向到这个连接，然后执行我们重写后的loadUserByUsername方法，这个方法会获得usrname参数，来看数据库有没有该用户，有就登录没有就报错</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806203140593.png" alt="image-20240806203140593" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806202906221.png" alt="image-20240806202906221" style="zoom:33%;"><h2 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h2><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>通常基于RBAC实现授权</p><p>RBAC分为两种方式：</p><p>基于角色的访问控制（Role-Based Access Control），扩展性差</p><p>基于资源的访问控制（Resource-Based Access Control）</p><h3 id="资源服务授权流程"><a href="#资源服务授权流程" class="headerlink" title="资源服务授权流程"></a>资源服务授权流程</h3><p>通过添加授权注解</p><p>在需要授权的接口处使用@PreAuthorize(“hasAuthority(‘权限标识符’)”)进行控制</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806213018165.png" alt="image-20240806213018165"></p><p>设置了@PreAuthorize表示执行此方法需要授权，如果当前用户请求接口没有权限则抛出异常</p><p>org.springframework.security.access.AccessDeniedException: 不允许访问</p><p>这是因为，我们登录后将jwt令牌存在cookie中里面包好authorities信息，里面放的是test，不是xc_teachmanager_course_list，<strong>需要再出数据库中插入该权限并写入令牌中</strong></p><h3 id="如何授权，授权管理"><a href="#如何授权，授权管理" class="headerlink" title="如何授权，授权管理"></a>如何授权，授权管理</h3><p>5张数据表</p><p>为了为用户xc_user方便分配权限创建了角色表xc_role（学生角色、老师角色）,xc_menu菜单表存放的就是权限标识</p><p>建立角色xc_role和权限xc_menu的关系表xc_permission</p><p>建立角色xc_role和用户xc_user的关系表xc_user_role</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806222852255.png" alt="image-20240806222852255" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240806223715369.png" alt="image-20240806223715369" style="zoom:33%;"><h3 id="细粒度权限"><a href="#细粒度权限" class="headerlink" title="细粒度权限"></a>细粒度权限</h3><p>不同机构只能查询自己机构的课程，他们都可以查询课程但查询的课程不同</p><h3 id="实战：还没做，看看瑞吉的短信发送流程"><a href="#实战：还没做，看看瑞吉的短信发送流程" class="headerlink" title="实战：还没做，看看瑞吉的短信发送流程"></a>实战：还没做，看看瑞吉的短信发送流程</h3><ul><li>找回密码（实战）手机验证码和邮箱<ul><li>发送验证码</li><li>找回密码</li><li>两部操作</li></ul></li><li>注册（实战）</li></ul><h3 id="选课学习"><a href="#选课学习" class="headerlink" title="选课学习"></a>选课学习</h3><p>实现学生选课、下单支付、学习的整体流程</p><h4 id="选课"><a href="#选课" class="headerlink" title="选课"></a>选课</h4><p>选课无论收不收费都添加到<strong>选课记录表</strong>中，根据状态字段判断是添加成功还是待支付</p><p>选课成功会添加到我的课程表中（免费直接加入），收费支付成功才会加入到我的课程表</p><p><strong>添加选课流程</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240807100556869.png" alt="image-20240807100556869" style="zoom:33%;"><p>订单依赖于选课记录表，我的课程表也依赖于选课记录表</p><p>学习中心服务远程调用内容管理服务来判断该课程是否收费</p><p>在content中添加查询课程发布信息，url改为以&#x2F;r开头，该服务用于内部调用不需要进行用户登录访问所以直接放行，在服务内部不用穿令牌可以直接访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;查询课程发布信息&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//此接口主要提供其它微服务远程调用，所以此接口不用授权，本项目标记此类接口统一以 /r开头。</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/r/coursepublish/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CoursePublish <span class="title function_">getCoursepublish</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span> &#123;</span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> coursePublishService.getCoursePublish(courseId);</span><br><span class="line">     <span class="keyword">return</span> coursePublish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行feign远程调用时会将字符串转成LocalDateTime，在CoursePublish 类中LocalDateTime的属性上边添加如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING,pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br></pre></td></tr></table></figure><p>之前我们在base包编写过配置类字符串转localDateTime，localDateTime转字符串，但这个限于restful接口中，也就是http请求请求接口把请求到的对象转json出现日期格式问题，现在我们是feignclient远程调用。</p><h4 id="添加选课接口开发"><a href="#添加选课接口开发" class="headerlink" title="添加选课接口开发"></a>添加选课接口开发</h4><p>xc_choose_course选课记录表，没有约束，可能会存在多个相同的记录，依赖的是课程（参数）</p><p>xc_course_table我的课程表，有约束，索引为userId和courseId，唯一，因此不能出现两个id都相同的记录。依赖的是选课记录表（参数）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加免费课程,免费课程加入选课记录表、我的课程表</span></span><br><span class="line">    <span class="keyword">public</span> XcChooseCourse <span class="title function_">addFreeCoruse</span><span class="params">(String userId, CoursePublish coursepublish)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">免费课程还要添记到我的课程表</span><br><span class="line">    </span><br><span class="line"><span class="comment">//添加到我的课程表</span></span><br><span class="line">    <span class="keyword">public</span> XcCourseTables <span class="title function_">addCourseTabls</span><span class="params">(XcChooseCourse xcChooseCourse)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>选课记录DTO与我的课程表DTO都有, learningStatus 字段.</p><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>在本项目中不仅选课需要下单、购买学习资料、老师一对一答疑等所以收费项目都需要下单支付。</p><p>所以本项目设计通用的订单服务，通用的订单服务承接各业务模块的收费支付需求，当用户需要交费时统一生成商品订单并进行支付。</p><p> 扫码支付和第三方对接</p><p>专门为支付创建一个支付微服务，包含一张订单表，记录了所有支付的订单</p><p>分为三大块：<strong>生成支付订单、用户完成支付、支付结果通知</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240807231233506.png" alt="image-20240807231233506" style="zoom:33%;"><p>微信提供的支付方式地址<a href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p><p>最终使用支付宝配置沙箱环境进行测试</p><p>下单、退款、对账</p><p>支付宝支付接口定义<a href="https://opendocs.alipay.com/open/203/105285/">https://opendocs.alipay.com/open/203/105285/</a></p><p>配置过程我们需要appid以及应用私钥和支付宝公钥</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240808110809221.png" alt="image-20240808110809221" style="zoom:50%;"><h4 id="支付接口"><a href="#支付接口" class="headerlink" title="支付接口"></a>支付接口</h4><p>你通过模拟器去扫码，在模拟器里面有自己的ip地址，模拟器和pc端是独立的，所以你访问localhost并不会访问到订单服务</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240808115307361.png" alt="image-20240808115307361" style="zoom:50%;"><h4 id="支付结果查询接口（也就是主动查询，防止支付宝通知没有通知到）"><a href="#支付结果查询接口（也就是主动查询，防止支付宝通知没有通知到）" class="headerlink" title="支付结果查询接口（也就是主动查询，防止支付宝通知没有通知到）"></a>支付结果查询接口（也就是主动查询，防止支付宝通知没有通知到）</h4><p>这两个账号<strong>二选一</strong></p><p>out_trade_no商品订单号:  是在下单请求时指定的商品订单号。</p><p>支付宝的交易流水号trade_no：是支付完成后支付宝通知支付结果时发送的trade_no</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240808140549257.png" alt="image-20240808140549257"></p><h4 id="支付结果通知接口"><a href="#支付结果通知接口" class="headerlink" title="支付结果通知接口"></a>支付结果通知接口</h4><p>对于手机网站支付产生的交易，支付宝会通知商户支付结果，有两种通知方式，通过return_url、notify_url进行通知，使用return_url不能保证通知到位，推荐使用notify_url完成支付结构通知。</p><p>这个重定向是支付成功后，zfb给你手机返回一个重定向地址，然后跳转到这个地址，上面请求路径上面会有一些参数，有点类似获取密钥那会</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alipayRequest.setNotifyUrl(<span class="string">&quot;https://1325-223-81-193-57.ngrok-free.app/orders/paynotify&quot;</span>);<span class="comment">//在公共参数中设置回跳和通知地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240808154411344.png" alt="image-20240808154411344"></p><h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><h3 id="生成支付二维码"><a href="#生成支付二维码" class="headerlink" title="生成支付二维码"></a>生成支付二维码</h3><p>支付测试完毕，现在应用于项目中，对接支付接口</p><p>需要三张表，订单表和订单明细表是一对多的关系，我们会将支付记录表的记录号传给第三方，不是传递订单表的订单号</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240808162205802.png" alt="image-20240808162205802"></p><p>生成二维码的接口：创建商品订单、生成支付记录、生成二维码，只要涉及创建订单一般都存在订单表和订单明细表</p><p>订单表：记录订单信息</p><p>订单明细表：记录订单的详细信息</p><p>支付记录表：记录每次支付的详细信息</p><p>用户每次发起支付都创建一个新的支付记录 ，此支付记录与商品订单关联。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240808162832764.png" alt="image-20240808162832764" style="zoom:50%;"><p>插入订单需要确定订单号也就是主键，这个不是自增主键，<strong>使用雪花算法</strong>生成</p><p>第一：确定订单号的生成规则 </p><p>订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：</p><p>1、时间戳+随机数</p><p>年月日时分秒毫秒+随机数</p><p>2、高并发场景</p><p>年月日时分秒毫秒+随机数+redis自增序列</p><p>如果在极端情况下，“年月日时分秒毫秒”和“随机数”都相同，Redis的自增序列能够确保最终生成的ID仍然是唯一的。例如，如果两个请求在同一毫秒内 生成了相同的随机数，Redis自增序列会提供不同的递增值，使得最终生成的ID不同。</p><p>3、订单号中加上业务标识（淘宝订单的使用）</p><p>订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。</p><p>4、<strong>雪花算法</strong></p><p>雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。</p><p><strong>out_business_id有唯一性约束，因此同一个选课只有一个订单</strong>，商品订单的数据来源于选课记录，在订单表需要存入选课记录的ID，这里需要作好幂等处理。</p><p><strong>每次讲支付记录号传给支付宝， %s占位符，用来获取支付记录号</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812095641562.png" alt="image-20240812095641562" style="zoom:33%;"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pay:</span></span><br><span class="line"> <span class="attr">qrcodeurl:</span> <span class="string">http://192.168.101.1:63030/orders/requestpay?payNo=%s</span></span><br></pre></td></tr></table></figure><p>扫码下单测试的时候还是有点bug就是price是0，应该为1的，不知道哪里出了问题不想改了，费时间，测试直接把支付记录表的价格改一下就行，要不为0支付宝扫码会出现价格异常，找到问题了添加选课这里收费课程价格设置为0</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812113047247.png" alt="image-20240812113047247" style="zoom:33%;"><h3 id="查询支付结果"><a href="#查询支付结果" class="headerlink" title="查询支付结果"></a>查询支付结果</h3><p>根据前边我们调研的获取支付结果的接口，包括：主动查询支付结果、被动接收支付结果。</p><h4 id="主动查询"><a href="#主动查询" class="headerlink" title="主动查询"></a>主动查询</h4><p>用户点击<strong>支付完成</strong>，会查询支付结果，<strong>并且还要更新支付记录表和订单表的状态</strong></p><p>json序列化会导致Long类型转String类型出现精度损失，只要json转换，将long转为string都是用这中序列化方式，在base中配置，就不用在每个属性上去配置了</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812161136937.png" alt="image-20240812161136937" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812161303500.png" alt="image-20240812161303500" style="zoom:33%;"><p><strong>md支付完成一直点不了。换了个火狐才行谷歌点不了</strong></p><p>更新支付结果：</p><p>如果支付成功–&gt;更新支付记录表的状态为支付成功–&gt;更新订单表的状态为支付成功</p><h4 id="被动查询"><a href="#被动查询" class="headerlink" title="被动查询"></a>被动查询</h4><p><strong>支付结果通知</strong>，在扫码的时候给支付宝回调地址，支付完成后，支付宝回请求这个controller</p><p><strong>不用点击支付完成，自动更新支付状态</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812212117090.png" alt="image-20240812212117090" style="zoom:33%;"><h3 id="支付通知"><a href="#支付通知" class="headerlink" title="支付通知"></a>支付通知</h3><p>订单服务通过消息队列将支付结果发给学习中心服务，消息队列采用发布订阅模式。</p><p>1、订单服务创建支付结果通知交换机。</p><p>2、学习中心服务绑定队列到交换机。</p><p>交换机为Fanout广播模式</p><p>直接feign是同步调用，需要等待，有级联问题，耦合强拓展差</p><p>用feign耦合度太高了，如果一个服务挂了，所有服务不都干不了活了</p><p>其实是可以的，异步调用主要是用于避免高并发下的阻塞</p><p><strong>支付服务</strong>通过消息队列把消息通知到 <strong>学习中心服务</strong>（订单服务作为通用服务在订单支付成功后需要将支付结果异步通知给其它微服务。）</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812212401900.png" alt="image-20240812212401900"></p><p>微服务收到支付结果根据订单的类型去更新自己的业务数据。</p><p>order生成，learning消费，都要加入rabbitMq依赖,以及配置，还要加入配置文件（创建交换机、创建队列，绑定交换机和队列）</p><p>为什么生成者和消费者都加入配置文件，防止那一方启动起来都不报错（因为没有创建交换机或队列并绑定而报错，这里不会重复创建）</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812215526623.png" alt="image-20240812215526623" style="zoom:33%;"><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240812215808188.png" alt="image-20240812215808188" style="zoom:33%;"><p>会先把消息持久化到数据库中</p><p>不仅交换机和队列要持久化，消息本身也要持久化</p><p>之前自己写了个消息sdk用来对消息表进行增删改查</p><p><strong>消费方</strong>学习中心服务，更新选课记录为<strong>选课成功</strong>，并将课程插入到<strong>我的课程表中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费方监听队列</span></span><br><span class="line"><span class="comment">//监听消息队列接收支付结果通知</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = PayNotifyConfig.PAYNOTIFY_QUEUE)</span></span><br></pre></td></tr></table></figure><p>消息中的知识用了两个字段，即选课id和订单类型，原因如下：</p><p>因为订单类型能判断是学习中心服务的业务范围，然后学习中心服务收到支付结果要做的事情也只需要选课记录id这个值就可以实现，所以就传这两个</p><p>测试：把之前支付成功的课程，在支付记录表中改为支付未成功也就是将602002改为602001，然后点击支付成功，order会发送消息，learning会接受，最终更新选课表的选课状态为701002到701001并在我的课程表中添加课程记录</p><h2 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h2><h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240813113622332.png" alt="image-20240813113622332" style="zoom:33%;"><h4 id="查询课程信息"><a href="#查询课程信息" class="headerlink" title="查询课程信息"></a>查询课程信息</h4><p>首先需要知道课程是否收费，要拿到课程信息</p><h4 id="获取视频"><a href="#获取视频" class="headerlink" title="获取视频"></a>获取视频</h4><p>工具类只能通过springsecurity解析令牌拿到当前用户的，接令牌的是api工程接。service不能接令牌，用户相关信息只能在springsecurity整合的api得到，service得不到</p><p>门户网站learning.html有bug呢</p><p><strong>试学部分懒得写了</strong></p><p>默认不放的是第一个视频</p><p>2号课程添加了章节后，还没重新上传至minio所以应该没显示</p><p>测试117号课程正常</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240813171201263.png" alt="image-20240813171201263"></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240813171355426.png" alt="image-20240813171355426"></p><h4 id="我的课程表"><a href="#我的课程表" class="headerlink" title="我的课程表"></a>我的课程表</h4><p>需要配置二级域名</p><p>查询我的课程表</p><p>需要传递用户id参数</p><h2 id="至此所有需求完结"><a href="#至此所有需求完结" class="headerlink" title="至此所有需求完结"></a>至此所有需求完结</h2><h3 id="找回密码没做呢"><a href="#找回密码没做呢" class="headerlink" title="找回密码没做呢"></a>找回密码没做呢</h3><h3 id="试学课程也没做"><a href="#试学课程也没做" class="headerlink" title="试学课程也没做"></a>试学课程也没做</h3><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>DevOps是一种思想理念，它涵盖开发、测试、运维的整个过程。DevOps追求的目标是提高软件开发、测试、运维、运营等各部门的沟通与协作质量，DevOps强调软件开发人员与软件测试、软件运维、质量保障（QA）部门之间有效的沟通与协作，强调通过自动化的方法去管理软件变更、软件集成，使软件从构建到测试、发布更加快捷、可靠，最终按时交付软件。</p><p>CI&#x2F;CD 是近年来企业有效实施DevOps的具体方案。</p><p>CI&#x2F;CD 包含了一个 CI 和两个 CD，CI全称 Continuous Integration，表示持续集成，CD包含 Continuous Delivery和 Continuous Deployment，分别是持续交付和持续部署，三者具有前后依赖关系。</p><p><strong>持续集成–&gt;持续交付–&gt;持续部署</strong></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240813202406428.png" alt="image-20240813202406428" style="zoom:33%;"><p><strong>K8s</strong>：使用镜像创建容器部署，对容器进行编排</p><p>本次项目部署实战旨在理解CI&#x2F;CD的流程，考虑Kubernates的复杂性课堂上我们用Jenkins代替Kubernates完成容器部署。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240813202236956.png" alt="image-20240813202236956" style="zoom:33%;"><p>package：打包</p><p>install：打包完成后上传到本地仓库</p><p>deploy：打包完后上传到私服</p><p>Clean：清除target目录下的内容</p><p>默认打的jar包没办法运行所以要加springboot打包插件</p><p>-DskipTests：跳过测试，maven打包时会自动把单元测试方法都执行一遍（持续集成：持续的合并后然后集成测试），  现在不测试（之前编写的test方法）跳过就行</p><p>docker logs  -f xuecheng-plus-checkcode</p><h4 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h4><p>jenkins服务器（每一个容器都是一个服务器）会通过ssh远程登录测试服务器进行拉去镜像创建容器</p><p>1、将代码 使用Git托管</p><p>2、在jenkins创建任务，从Git拉取代码。</p><p>3、拉取代码后进行自动构建：测试、打包、部署。</p><p>首先将代码打成镜像包上传到docker私服。运行私有库Registry——相当于本地有个私有Docker hub</p><p>Dokcer Registry简介以及使用方法：<a href="https://www.cnblogs.com/Chary/p/18095027">https://www.cnblogs.com/Chary/p/18095027</a></p><p>自动创建容器、启动容器。</p><p>4、当有代码push到git实现自动构建。</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814203203016.png" alt="image-20240814203203016"></p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814205722091.png" alt="image-20240814205722091" style="zoom:33%;"><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><p>视频播放页面用户未登录也可以访问，当用户观看试学课程时需要请求服务端查询数据，接口如下：</p><p>1、根据课程id查询课程信息。</p><p>2、根据文件id查询视频信息。</p><p>这些接口在用户未认证状态下也可以访问，如果接口的性能不高，当高并发到来很可能耗尽整个系统的资源，将整个系统压垮，所以特别需要对这些暴露在外边的接口进行优化。</p><p><strong>白名单接口：用户无需认证就能访问，针对这种接口，如果有动态数据要优先进行测试</strong></p><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>压力测试常用的性能指标如下：</p><p>1、吞吐量</p><p>吞吐量是系统每秒可以处理的事务数，也称为TPS（Transaction Per Second）。</p><p>比如：一次点播流程，从请求进入系统到视频画图显示出来这整个流程就是一次事务。</p><p>所以吞吐量并不是一次数据库事务，它是完成一次业务的整体流程。</p><p>2、响应时间</p><p>响应时间是指客户端请求服务端，从请求进入系统到客户端拿到响应结果所经历的时间。响应时间包括：最大响应时间、最小响应时间、平均响应时间。</p><p>3、每秒查询数</p><p>每秒查询数即QPS（Queries-per-second），它是衡量查询接口的性能指标，比如：商品信息查询， 一秒可以请求该接口查询商品信息的次数就是QPS。</p><p>拿查询接口举例，一次查询请求内部不会再去请求其它接口，此时  QPS&#x3D;TPS</p><p>如果一次查询请求内容需要远程调用另一个接口查询数据，此时 QPS&#x3D;2 * TPS</p><p>4、错误率</p><p>错误率 是一批请求发生错误的请求占全部请求的比例。</p><p><strong>不同的指标其要求不同，比如现在进行接口优化，优化后的接口响应时间应该越来越小，吞吐量越来越大，以及QPS值也是越大越好，错误率要保持在一个很小的范围。</strong></p><p>另外除了关注这些性能指标以外还要关注系统的负载情况：</p><p>1、CPU使用率，不高于85%</p><p>2、内存利用率，不高于 85%</p><p>3、网络利用率，不高于 80%</p><p>4、磁盘IO</p><p>磁盘IO的性能指标是IOPS (Input&#x2F;Output Per Second)即每秒的输入输出量(或读写次数)。</p><p><strong>如果过大说明IO操作密集，IO过大也会影响性能指标。</strong></p><p>对查询课程发布借口进行压力测试</p><p><strong>加open是通过nginx进行访问，先进行了一次代理转发到gateway</strong>—–这个不对啊，网友说错了，应该</p><p>是他当时在网关里设了白名单全放行了所以不用open也能查</p><p>&#x2F;<strong>&#x3D;临时全部都打开<br>&#x2F;auth&#x2F;</strong>&#x3D;认证地址<br>&#x2F;content&#x2F;open&#x2F;<strong>&#x3D;内容管理公开访问接口<br>&#x2F;media&#x2F;open&#x2F;</strong>&#x3D;媒资管理公开访问接口</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>1.不通过网关</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814104128144.png" alt="image-20240814104128144"></p><p>2.改变日志级别从debug到info</p><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><p>测试用例是根据id查询课程信息，这里不存在复杂的SQL，也不存在数据库连接不释放的问题，暂时不考虑数据库方面的优化。</p><p>课程发布信息的特点的是查询较多，修改很少，这里考虑将课程发布信息进行缓存。</p><p><strong>也就是将白名单接口查询数据放到缓存中</strong> <strong>把我的订单我的选课这些访问量大的放到缓存中（我的学习那里）</strong></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814111711623.png" alt="image-20240814111711623"></p><h3 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h3><p>高并发导致的问题</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>大量并发去访问一个数据库不存在的数据，由于缓存中没有该数据导致大量并发查询数据库，这个现象要缓存穿透。缓存穿透可以造成数据库瞬间压力过大，连接数等资源用完，最终数据库拒绝连接不可用。</p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814114944583.png" alt="image-20240814114944583" style="zoom:33%;"><p>1.增加校验机制：key有一定规则</p><p>2.布隆过滤器：0表示过滤器不存在，数据库不存在</p><ul><li>Google工具包Guava实现。</li><li>redisson 。</li></ul><p>3.缓存空值或特殊值：查不到就缓存空值，但是要注意：<strong>如果缓存了空值或特殊值要设置一个短暂的过期时间。</strong></p><p><strong>使用3改进后，当访问不存在数据不会在一直查数据库，当查到缓存空后直接return，结束</strong></p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是缓存中大量key失效后当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>造成缓存雪崩问题的原因是是大量key拥有了相同的过期时间，比如对课程信息设置缓存过期时间为10分钟，在大量请求同时查询大量的课程信息时，此时就会有大量的课程存在相同的过期时间，一旦失效将同时失效，造成雪崩问题。</p><p>如何解决？</p><p><strong>1、使用同步锁控制查询数据库的线程</strong></p><p>使用同步锁控制查询数据库的线程，只允许有一个线程去查询数据库，查询得到数据后存入缓存。</p><p><strong>2、对同一类型信息的key设置不同的过期时间</strong></p><p>通常对一类信息的key设置的过期时间是相同的，这里可以在原有固定时间的基础上加上一个随机时间使它们的过期时间都不相同。</p><p><strong>3、缓存预热</strong></p><p>不用等到请求到来再去查询数据库存入缓存，可以提前将数据存入缓存。使用缓存预热机制通常有专门的后台程序去将数据库的数据同步到缓存。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814153134264.png" alt="image-20240814153134264" style="zoom:33%;"><p>缓存击穿是指大量并发访问同一个热点数据，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>比如某手机新品发布，当缓存失效时有大量并发到来导致同时去访问数据库。</p><p><strong>如何解决缓存击穿？</strong></p><p><strong>1、使用同步锁控制查询数据库的线程</strong>（尽量缩小锁的范围，如只锁数据库那部分代码）</p><p>使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到数据库存入缓存。</p><p><strong>对查询缓存的代码不用synchronized加锁控制，只对查询数据库进行加锁，双重检查锁</strong>，这个操作好牛逼</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814155120960.png" alt="image-20240814155120960"></p><p><strong>锁整个方法</strong></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814155404675.png" alt="image-20240814155404675"></p><p><strong>只锁数据库方法</strong></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814155645661.png" alt="image-20240814155645661"></p><p><strong>2、热点数据不过期</strong></p><p>可以由后台程序提前将热点数据加入缓存，缓存过期时间不过期，由后台程序做好缓存同步。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><strong>本地锁问题：</strong>上边的程序使用了同步锁解决了缓存击穿、缓存雪崩的问题，保证同一个key过期后只会查询一次数据库。如果将同步锁的程序分布式部署在多个虚拟机上则无法保证同一个key只会查询一次数据库。</p><p><strong>一个同步锁程序只能保证同一个虚拟机中多个线程只有一个线程去数据库，如果高并发通过网关负载均衡转发给各个虚拟机，此时就会存在多个线程去查询数据库情况，因为虚拟机中的锁只能保证该虚拟机自己的线程去同步执行，无法跨虚拟机保证同步执行</strong></p><p>同步锁仅仅只在当前jvm有效，不能锁住其他jvm，有几个jvm进程会查几次</p><p>这个同步锁,当在多个实例的情况下,它只能锁住当前JVM(当前实例)的线程,换句话说,每个服务实例都会有一个线程去查数据库</p><p>分布式锁：有多个jvm争抢的锁</p><h4 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h4><p>已经实现过了，在前面课程发布时候，分布式任务调度中实现</p><h4 id="基于redis实现锁"><a href="#基于redis实现锁" class="headerlink" title="基于redis实现锁"></a>基于redis实现锁</h4><p><strong>1.SETNX实现分布式锁</strong></p><p>SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。</p><p><strong>原子性可以用Lua脚本去解决，但过期时间设置难以解决，到底设置多少，大了性能低，小了锁被抢</strong></p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814165943463.png" alt="image-20240814165943463"></p><p>为了避免删除别的线程设置的锁需要使用redis去执行Lua脚本的方式去实现（让这段代码具有原子性，中间执行过程不被cpu中断），这样就具有原子性，但是过期时间的值设置不存在不精确的问题。</p><p><strong>2.基于redisson实现分布式锁</strong></p><p>可以把我们常用的数据结构放到redis中去，也可实现分布式锁</p><p><strong>synchronized锁是阻塞式的，一个线程拿到锁执行，其他线程等</strong></p><p><strong>ReentrantLock是线程拿到锁就执行，其他线程开始自旋，看能不能获取到锁</strong></p><p>Redisson实现了自旋锁的Lock接口</p><p>阻塞需要线程之间的切换，有些程序执行时间可能都没线程切换时间长，这个时候自旋就不用cpu切换上下文–网友</p><p>自旋锁的好处，那就是自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销</p><p>WatchDog线程对锁的过期时间自动续期，过期时间默认30s</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814190648688.png" alt="image-20240814190648688"></p><p>**lock()**：</p><ul><li>此方法为加锁，但是锁的有效期采用<strong>默认30秒</strong></li><li>如果主线程未释放，且当前锁未调用unlock方法，则进入到<strong>watchDog机制</strong></li><li>如果主线程未释放，且当前锁调用unlock方法，则直接释放锁</li></ul><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240814193811057.png" alt="image-20240814193811057"></p><p><strong>任务：</strong>8.14</p><p>啥事registry私服？</p><p>看看为啥要部署门户而不直接在前端，是因为门户的话可以把一些动态资源转换为静态资源，从而不让请求直接访问数据库么？</p><p> 前端vue是机构端用的 原来门户是学生用的</p><p>异常处理，jsr303？</p><p>浏览器通过ajax请求调用服务端出现跨域</p><p><img src="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/image-20240815095607852.png" alt="image-20240815095607852"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java相关</title>
      <link href="/2024/07/24/java%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/07/24/java%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p></li><li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于<strong>堆内存</strong>，局部变量则存在于<strong>栈内存</strong>。</p></li><li><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240701202652986.png" alt="image-20240701202652986"></p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240701202708263.png" alt="image-20240701202708263"></p></li><li><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存中</strong>），对象引用指向对象实例（<strong>对象引用存放在栈内存中</strong>）。Student s1 &#x3D; new Student(); – 在占栈内存中声明一个名字为s1的空间存储Student这个类对象的地址值。这行代码虚拟机至少做了7步，虚拟机会自动调用主入口的main方法</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531101956061.png" alt="image-20240531101956061" style="zoom:50%;"></li><li><p>变量里面存储的是真实的数据，数组变量记录的是数组数据在堆内存中存放的的地址值，真实数据在堆内存中存放，虚拟机构成就是这样，<strong>方法区中临时存储的字节码文件。</strong></p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240530112403058.png" alt="image-20240530112403058" style="zoom:50%;"><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240530112335429.png" alt="image-20240530112335429" style="zoom:50%;"></li><li><p>（GPT提供）在Java中，二维数组的内存空间地址并不是连续的。这是因为Java中的二维数组实际上是一个数组的数组，即一个外层数组，其中每个元素都是一个指向内层数组的引用。具体来说，内存布局如下：</p><ol><li><strong>外层数组</strong>：<ul><li>外层数组的元素存储的是指向内层数组的引用。</li><li>这些引用是连续存储的，因为外层数组是一个普通的引用类型数组。</li></ul></li><li><strong>内层数组</strong>：<ul><li>每个内层数组本身也是一个独立的数组。</li><li>这些内层数组在内存中的位置不一定是连续的，因为它们是独立分配的。</li></ul></li></ol></li><li><p>（GPT提供）在 Java 中，对象的引用是指存储对象内存地址的变量，而不是对象本身。引用变量用于指向对象，使得我们可以通过引用变量来访问和操作该对象的属性和方法。</p><h3 id="对象和对象引用的区别"><a href="#对象和对象引用的区别" class="headerlink" title="对象和对象引用的区别"></a>对象和对象引用的区别</h3><ol><li><strong>对象</strong>：对象是类的一个实例，它在内存中占有一定的空间，并包含类定义的属性和方法。</li><li><strong>对象引用</strong>：对象引用是一个变量，用于存储对象的内存地址，通过引用变量可以访问对象的属性和方法。</li></ol></li><li><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></li></ol><p>将字节码文件加载到方法区中，并将main()方法进行临时存储</p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531100935092.png" alt="image-20240531100935092"></p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531101512207.png" alt="image-20240531101512207"></p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531104232585.png" alt="image-20240531104232585"></p><ol start="9"><li><p>字符串的值不能更改，一旦创建不能更改，<strong>StringTable(串池，字符串常量池 )，用来存储只有<u>直接赋值</u>的方式获取的字符串才存在这个池子中</strong>，JDK7以前都存在方法区，以后存储在<strong>堆内存</strong>中</p></li><li><ul><li><p>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</p></li><li><p>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</p></li><li><p>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</p></li><li><p>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</p></li></ul></li><li><p>StringBuilder可以看成一个容器，创建之后里面的内容是可变的，他并不是一个字符串，每次完成操作后还需要变为字符串toString()。</p></li></ol><ul><li><p>提高字符串的效率。</p></li><li><p>一般字符串拼接的时候会用到</p></li><li><p>字符串反转的时候也会用到</p></li></ul><ol start="12"><li>&#x3D;&#x3D;</li></ol><ul><li>基本数据类型比较的是数据值</li><li>引用数据类型比较的地址值，就是两个变量s1，s2记录的地址值。</li></ul><ol start="13"><li>抽象方法所在的类必须是抽象类</li></ol><ul><li><p>抽象类是对一种<strong>事物的抽象</strong>，即对类抽象，接口是一种规则，是对<strong>行为的抽象</strong>，不是表示事物。</p></li><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p></li></ul><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote><ul><li><strong>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</strong>。</li></ul><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote><ul><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li></ul><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote><ul><li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。</li></ul><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote><ul><li>抽象类存在的意义是为了被子类继承。</li></ul><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote><ol start="14"><li>final修饰的变量是引用类型</li></ol><blockquote><p>那么变量存储的<strong>地址值不能发生改变</strong>，对象<strong>内部的可以改变</strong></p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240602155428857.png" alt="image-20240602155428857" style="zoom:50%;"></blockquote><ol start="15"><li><p>多态：对象的多种形态。一定要有继承&#x2F;实现的关系</p><blockquote><p>创建对象(多态方式)</p><p>Fu f &#x3D; new Zi();</p></blockquote></li></ol><p><strong>要注意的是：</strong></p><ul><li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li><li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象。</li><li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li></ul><ol start="16"><li>不同权限的访问能力</li></ol><table><thead><tr><th></th><th>public</th><th>protected</th><th>默认</th><th align="left">private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td align="left">√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td align="left"></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td align="left"></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td align="left"></td></tr></tbody></table><ol start="17"><li>二维数组内存图</li></ol><p>数组的地址值表示：[I@119d7047,[–表示数组，I表示类型(int类型)，@固定类型，119d7047表示真正的地址值</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240602171425025.png" alt="image-20240602171425025" style="zoom:50%;"><ol start="18"><li>Java中只有<strong>值传递</strong>，没有引用传递</li></ol><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中<strong>地址值的拷贝</strong>，同样也会创建副本。</li></ul><ol start="19"><li>Java集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</li></ol><p>如何选用集合：</p><ul><li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li><li>我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul><ol start="20"><li><p>Comparable和Comparator</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604202430664.png" alt="image-20240604202430664" style="zoom:50%;"><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604202525308.png" alt="image-20240604202525308"></p><p>简单理解：</p><blockquote><p>o1 - o2 :升序排序。o2 - o1:降序排序</p></blockquote></li><li><p>生产者消费者模型 </p></li><li><p>包装类：基本数据类型对应的引用类型，把基本数据类型变成了对象（crtl+b跟进，ctrl+alt+左键返回）</p></li></ol><ul><li>Int类型所对应的包装类为Integer，在java中使用Integer这个类来描述正数。</li><li>以前的包装类如何进行计算<ul><li>帮对象进行装箱，变成基本数据类型</li><li>相加</li><li>把得到的结果再次进行装箱（再变回包装类）</li><li>JDK5的时候提出了一个机制：自动装箱和自动拆箱</li></ul></li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604170849688.png" alt="image-20240604170849688"></p><ol start="23"><li>JDK(Java Development kit)是java开发工具包，JRE(Java Runtime Environment)是Java运行环境</li></ol><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604172704257.png" alt="image-20240604172704257"></p><h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605103946606.png" alt="image-20240605103946606" style="zoom:33%;"><h3 id="Collection单列集合"><a href="#Collection单列集合" class="headerlink" title="Collection单列集合"></a>Collection单列集合</h3><ul><li>如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法。</li></ul><blockquote><p>Collection<Student> Coll &#x3D; new ArrayList&lt;&gt;();</Student></p><p>Student是我们的自定义对象</p></blockquote><p>如果存储的是自定义对象，没有重写equals方法，那么默认使用Object类中的equals方法进行判断，而Object类中equals方法，依赖地址值进行判断。不需要自己写，在Student类中idea生成</p><ul><li>Collection的遍历方式（在遍历集合的时候不依赖索引，因为他的儿子set没有索引，只有List儿子有）</li></ul><blockquote><p>迭代器遍历、增强for遍历、Lambda表达式遍历</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------迭代器遍历---------------</span></span><br><span class="line"><span class="comment">//Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</span></span><br><span class="line">    Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">    <span class="comment">//用while循环改进元素的判断和获取</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------增强for遍历---------------</span></span><br><span class="line"><span class="comment">//1,数据类型一定是集合或者数组中元素的类型</span></span><br><span class="line">        <span class="comment">//2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素</span></span><br><span class="line">        <span class="comment">//3,list就是要遍历的集合或者数组</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//---------------Lambda遍历---------------</span></span><br><span class="line"><span class="comment">//2.利用匿名内部类的形式</span></span><br><span class="line">        <span class="comment">//底层原理：</span></span><br><span class="line">        <span class="comment">//其实也会自己遍历集合，依次得到每一个元素</span></span><br><span class="line">        <span class="comment">//把得到的每一个元素，传递给下面的accept方法</span></span><br><span class="line">        <span class="comment">//s依次表示集合中的每一个数据</span></span><br><span class="line">       <span class="comment">/* coll.forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><h3 id="List中常见的方法和无种遍历方式"><a href="#List中常见的方法和无种遍历方式" class="headerlink" title="List中常见的方法和无种遍历方式"></a>List中常见的方法和无种遍历方式</h3><ul><li><p>remove方法有两个，当调用方法的时候，如果方法出现了重载现象，<strong>优先调用</strong>实参跟形参一致的那个方法。</p></li><li><p>List集合独有<strong>列表迭代器遍历</strong>（额外添加了一个方法，在遍历过程中可以添加元素，collection那个是可以remove元素），<strong>普通for循环</strong>(因为List集合存在索引)</p></li><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605103510248.png" alt="image-20240605103510248" style="zoom:33%;"></li></ul><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240611200840383.png" alt="image-20240611200840383" style="zoom:33%;"><p>考虑了两种情况</p><ul><li>添加第一个元素</li><li>添加第一个元素时，底层创建呢的新的长度为10的数组装满的情况，要装第十一元素了</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240611200709767.png" alt="image-20240611200709767"></p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240611200639523.png" alt="image-20240611200639523"></p><h3 id="Set系列集合-无序、不重复、无索引"><a href="#Set系列集合-无序、不重复、无索引" class="headerlink" title="Set系列集合: 无序、不重复、无索引"></a>Set系列集合: 无序、不重复、无索引</h3><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609154609801.png" alt="image-20240609154609801" style="zoom:33%;"><p>创建一个Set（接口）集合的对象，Set是接口不能创建Set的对象，要创建他的实现类的对象，需要使用Set接口里的方法，因此创建多态的方式创建对象</p><blockquote><p>Set <String>  &#x3D; new  HashSet&lt;&gt;() </String></p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621124517384.png" alt="image-20240621124517384" style="zoom:33%;"><p>哈希值：对象的整数表示，哈希值来确定当前对象添加在数组的哪个位置</p></blockquote><p>如果集合中存储的是自定义对象（像Sting、Integer的java底层已经重写好了），必须要重写** <strong>和</strong>equal<strong>方法，若没有重写他们在底层都是使用地址值进行计算和比较的， 意义不大，重写后根据对象的属性值进行计算</strong>哈希值<strong>和比较</strong>属性值**。</p><ul><li><p>HashSet:该集合底层采用<strong>哈希表</strong>存储数据</p></li><li><p>哈希表组成：</p><ul><li>JDK8之前：数组+链表</li><li>JDK8之后：数组+链表+红黑树</li></ul></li><li><p>LinkedHashSet：</p><ul><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609155239192.png" alt="image-20240609155239192" style="zoom:50%;"></li></ul></li><li><p>TreeSet：该集合底层是<strong>基于红黑树的数据结构</strong>实现排序的，增删改查性能都较好</p><ul><li><p>TreeSet排序时的两种比较方式：</p><ul><li>默认排序&#x2F;自然排序：Javabean类实现Comparable接口，指定比较规则，this表示需要添加的元素，o表示已经在红黑树中存在的元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span>&#123;</span><br><span class="line">  <span class="comment">//指定排序的规则</span></span><br><span class="line">  <span class="comment">//只看年龄，按照年龄生序排列</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.getAge() - o.getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609165309617.png" alt="image-20240609165309617"></p><ul><li>比较器排序：创建集合时，自定义Comparator比较器对象，指定比较规则（在创建TreeSet对象的时候，传递比较器的对象）,<strong>o1表示当前要添加的元素，o2表示已经存在红黑树存在的元素</strong></li></ul><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609170647023.png" alt="image-20240609170647023" style="zoom:33%;"><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609170714439.png" alt="image-20240609170714439" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">TreeSet&lt;Teacher&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Teacher&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Teacher o1, Teacher o2)</span> &#123;</span><br><span class="line">    <span class="comment">//o1表示现在要存入的那个元素</span></span><br><span class="line">    <span class="comment">//o2表示已经存入到集合中的元素</span></span><br><span class="line">              </span><br><span class="line">    <span class="comment">//主要条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o1.getAge() - o2.getAge();</span><br><span class="line">    <span class="comment">//次要条件,如果结果为0则按照字符串默认的排序规则o1.getName()是一个字符串，按照首字母排序</span></span><br><span class="line">    result = result == <span class="number">0</span> ? o1.getName().compareTo(o2.getName()) : result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><ul><li>默认使用第一种，如果第一种不能满足当前需求，就是用第二种（例如String字符串的排序规则在java底层已经写好了默认的排序，我们要进行更改就需要使用第二种方式重新排序 ）</li><li>两种排序方式都存在，使用第二种<ul><li>对象进行排序</li><li>实现Comparable接口，指定比较规则</li><li>创建集合时传递Comparator比较器对象，指定比较规则 ，Arrays类提供了重载的sorts方法</li><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240716155524563.png" alt="image-20240716155524563" style="zoom:33%;"></li></ul></li><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240716154939165.png" alt="image-20240716154939165"></li></ul></li><li><p>两种方式中关于返回值的规则</p><ul><li>如果返回值为负数，表示当前存入的元素是较小值，存左边</li><li>如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存</li><li>如果返回值为正数，表示当前存入的元素是较大值，存右边</li></ul></li><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609165647699.png" alt="image-20240609165647699" style="zoom:50%;"></li></ul></li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Lambda不受限于面向对象的语法特征（先创建对象，在写方法体）lambda表达式可以直接写方法体。</p><ul><li>Lambda表达式的注意点：<ul><li>Lambda表达式可以用来简化匿名内部类的书写</li><li>Lambda表达式只能简化函数式接口的匿名内部类的写法（调用一个方法的时候，如果方法的形参是一个接口，那么我们要传递这个接口的实现类对象，如果实现类对象只要用到一次，就可以用匿名内部类的形式书写）</li><li><strong>函数式接口</strong>：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解</li><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240716130445052.png" alt="image-20240716130445052"></li><li>实现一个接口需要重写里面所有的抽象方法，在没有名字的类中重写接口的抽象方法</li></ul></li><li>Lambda的省略规则：<ul><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时()也可以省略</li><li>如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。</li></ul></li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605100310461.png" alt="image-20240605100310461"></p><h3 id="Map双列集合"><a href="#Map双列集合" class="headerlink" title="Map双列集合"></a>Map双列集合</h3><p>Map是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的，接口不能直接创建对象需要创建实现类的对象，即多态的方式创建对象。</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621101448548.png" alt="image-20240621101448548" style="zoom:25%;"><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621122653973.png" alt="image-20240621122653973" style="zoom:50%;"><p>双列集合一次需要存一对数据，分为键和值</p><p>键值对–键值对对象–Entry对象</p><ul><li><p>put方法：添加&#x2F;覆盖</p><ul><li>在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null</li><li>在添加数据的时候，如果键存在，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回</li></ul></li><li><p>Map的遍历方式：1.键找值 2.键值对 3.Lambda表达式</p><ul><li><p><strong>第一种键找值</strong></p></li><li><p>获取所有键的集合。用keySet()方法实现</p></li><li><p>遍历键的集合，获取到每一个键。用增强for、迭代器或者lambda实现  </p></li><li><p>根据键去找值。用get(Object key)方法实现</p></li><li><p><strong>第二种键值对</strong>，依次获取所有的键值对对象</p></li><li><p>获取所有键值对对象的集合</p><ul><li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合</li></ul></li><li><p>遍历键值对对象的集合，得到每一个键值对对象</p><ul><li>用增强for实现，得到每一个Map.Entry</li></ul></li><li><p>根据键值对对象获取键和值</p><ul><li>用getKey()得到键</li><li>用getValue()得到值</li></ul></li><li><p><strong>第三种Lambda表达式遍历</strong></p></li><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621112123580.png" alt="image-20240621112123580" style="zoom:33%;"></li><li><p>Hashmap</p></li></ul><ul><li>HashMap底层是哈希表结构的</li><li>依赖hashCode方法和equals方法保证键的唯一：通过hashcode方法计算键的哈希值找到数组当中应存入的位置，如果该位置有元素，就是用equals方法比较键是否相同</li><li>如果键要存储的是自定义对象，需要重写hashCode和equals方法</li></ul></li><li><p>LinkedHashMap:</p></li></ul><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621194423556.png" alt="image-20240621194423556" style="zoom:33%;"><ul><li><p>TreeMap：</p><ul><li>TreeMap底层是红黑树结构</li><li>依赖自然排序或者比较器排序,对键进行排序</li><li>如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则</li><li>实现Comparable接口（i&#x3D;&#x3D;0 ? this.getName().compareTo(o.getName)）:i;–年龄一样按照姓名去比</li><li>compareTo底层是按照字符串中每一个字符在ascii表中的数字排列的</li></ul><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621202147429.png" alt="image-20240621202147429" style="zoom:33%;"><ul><li></li></ul></li></ul><ol start="28"><li>递归指的是方法中调用方法本身的现象，递归一定要有出口(什么时候不在调用方法)，否则就会出现内存溢出。</li></ol><p>心得：方法内部再次调用方法的时候，参数必须要更加的靠近出口。</p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605171208922.png" alt="image-20240605171208922"></p><p>快速排序使用了递归</p><h2 id="排序总结："><a href="#排序总结：" class="headerlink" title="排序总结："></a>排序总结：</h2><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605201112874.png" alt="image-20240605201112874" style="zoom:33%;"><h2 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h2><ul><li>如果我们没有给集合制定类型，默认认为所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型。</li><li>泛型，在添加数据的时候把类型进行统一</li><li>Java中的泛型是违泛型，使用泛型的时候数据存进去后数据还是会变成Object类型，在向外获取的时候，java集合底层会将Object类型按照泛型进行强转。</li><li>泛型类、泛型方法、泛型接口</li></ul><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606161803755.png" alt="image-20240606161803755" style="zoom:33%;"><ul><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606163713815.png" alt="image-20240606163713815" style="zoom:33%;"></li><li><p>泛型的通配符：</p></li></ul><p>Public static<E> void keepPet(ArrayList<E> list){}—–&gt;Public static (可省略) void keepPet(ArrayList&lt;?&gt; list){}，**<E>要写在修饰符的后面，Public static都为修饰符**</E></E></E></p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606192504208.png" alt="image-20240606192504208" style="zoom:50%;"><ul><li>泛型不具备继承性，但是数据具备继承性</li></ul><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606193438140.png" alt="image-20240606193438140" style="zoom:33%;"><h2 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h2><p>与时间复杂度类似，一般也适用大O表示法来衡量，一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本。</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240607214322504.png" alt="image-20240607214322504" style="zoom:50%;"><ol start="31"><li>平衡二叉树：任意节点的左右两个子树高度差不超过1</li></ol><ul><li><p>平衡二叉树旋转的四种情况</p><ul><li><p>左左</p><ul><li><p>左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 直接对整体进行右旋即可</p></li></ul></li><li><p>左右</p><ul><li><p>左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋</p></li></ul></li><li><p>右右</p><ul><li><p>右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 直接对整体进行左旋即可</p></li></ul></li></ul><ul><li><p>右左</p><ul><li><p>右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋</p></li></ul></li></ul></li></ul><h2 id="红黑树："><a href="#红黑树：" class="headerlink" title="红黑树："></a>红黑树：</h2><p>节点组成如下，是一种特殊的二叉查找树</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240608201105900.png" alt="image-20240608201105900" style="zoom:33%;"><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240608203557746.png" alt="image-20240608203557746"></p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240608203531737.png" alt="image-20240608203531737"></p><ol start="34"><li>链表中会存在内部类用来表示节点，一个节点由三部分构成</li></ol><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240613102244352.png" alt="image-20240613102244352"></p><ol start="35"><li><p>在Java中，entry一词通常用来指代程序的入口点（即main方法）或Map集合中的键值对。</p></li><li><p><strong>核心线程数 （corePoolSize）</strong>：核心线程的数量；它的作用可以这样理解：向线程池中添加任务，如果线程池中的线程数量小于 corePoolSize，那么直接新建线程执行任务；如果线程池中的线程数量大于corePoolSize，那么就会往 阻塞队列workQueue中添加任务，此时如果阻塞队列满了且线程池中的线程数量小于最大线程数 maximumPoolSize，那么也会新建一个线程执行任务；如果阻塞队列满且线程数量大于最大线程数maximumPoolSize，那么会执行饱和策略，默认的策略是抛弃要加入的任务。</p></li><li><p>移除数组元素的方法：快慢指针</p></li></ol><ul><li>快指针：用来获取新数组中的元素</li><li>慢指针：获取我们新数组中需要更新的位置</li></ul><ol start="38"><li>MySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TRANSACTION</code>。</li></ol><p>​只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li><p>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</p></li><li><p>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p></li><li><h3 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="如何分析 SQL 的性能？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD">如何分析 SQL 的性能？</a></h3></li><li><p>dump 线程</p></li><li><p>binlog、relay log</p></li><li><p>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</p></li></ul><ol start="39"><li><p>JDK上对toString方法的解释是：返回对象的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA&spm=1001.2101.3001.7020">字符串表示</a>形式。一般来说，toString方法返回一个“文本表示”此对象的字符串,    Object类的toString方法返回一个<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>，该字符串由该对象作为其实例的类的名称、@符号字符以及该对象哈希码的无符号十六进制表示形式组成。</p><blockquote><p>类名+@+哈希码</p></blockquote></li></ol><p>40.数据包与数据帧的区别</p><ol><li><p><strong>传输层级</strong>：</p><ul><li><strong>数据包</strong>：工作在网络层，用于跨网络的节点之间进行传输。</li><li><strong>数据帧</strong>：工作在链路层，用于直接相连的设备之间传输。</li></ul></li><li><p><strong>地址信息</strong>：</p><ul><li><strong>数据包</strong>：包含IP地址信息（源IP和目的IP），用于网络层的路由和寻址。</li><li><strong>数据帧</strong>：包含MAC地址信息（源MAC和目的MAC），用于链路层的设备通信。</li></ul></li><li><p><strong>错误检测</strong>：</p><ul><li><strong>数据包</strong>：可能包含校验和，用于检测IP包头的错误。</li><li><strong>数据帧</strong>：通常包含冗余校验码（CRC），用于检测整个帧的数据错误。</li></ul></li><li><p><strong>封装关系</strong>：</p><ul><li><strong>数据包</strong>：可能被封装在数据帧的帧体部分进行传输。</li><li><strong>数据帧</strong>：在链路层传输的基本单元，其帧体部分可以包含网络层的数据包。</li></ul></li><li><p><strong>网络层的的核心功能——转发与路由</strong>，必会！！！如果面试官问到了网络层，而你恰好又什么都不会的话，最最起码要说出这五个字——<strong>转发与路由</strong>。</p></li></ol><ul><li>转发：将分组从路由器的输入端口转移到合适的输出端口。</li><li>路由：确定分组从源到目的经过的路径。</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240622210900940.png" alt="image-20240622210900940"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助Mysql高效获取数据的数据结构（有序），数据库中的数据是存储在磁盘当中的，操作磁盘涉及到磁盘的I&#x2F;O，降低数据库的IO成本。</p><p>​MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><ul><li>二叉树的缺点：顺序插入时候，会形成一个链表，查询性能大大降低。大数据情况下，层级较深，检索速度满。</li><li>红黑树是自平衡二叉树，解决树的平衡问题，但依然存在大数据情况下，层级较深，检索速度满。</li><li>B树是<strong>多路</strong>平衡查找树，多路–》一个节点可以包含多个字节点，4个key对应5个指针，分别指向它的子节点。</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623164159422.png" alt="image-20240623164159422"></p><ul><li>B+树 ：所有的数据都会出现在叶子节点、叶子节点形成一个单向链表</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623164511878.png" alt="image-20240623164511878"></p><ul><li>Mysql使用的优化后的B+树索引结构，只有叶子节点存储数据，其他节点只起到索引数据的作用，每个节点都存储在页&#x2F;磁盘块上，页&#x2F;块大小为16K</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623164737468.png" alt="image-20240623164737468"></p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623165950891.png" alt="image-20240623165950891"></p><ul><li>Hash索引：</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623165335859.png" alt="image-20240623165335859"></p><ul><li><p>索引分类（在InnDB存储引擎中分为两种），一般索引分类有四种：主键索引(默认自动创建，只能有一个)、唯一索引、常规索引、全文索引</p><ul><li><strong>聚集索引</strong>：B+树的叶子节点下面存放的是这一行的数据</li><li><strong>二级索引</strong>：B+树的叶子节点下面存放的是这一行的id（主键值）</li><li>回表查询：先走二级索引找到对应的主键值，再根据主键值到聚集索引中获取这一行的数据</li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623171123177.png" alt="image-20240623171123177"></p></li></ul><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623171049100.png" alt="image-20240623171049100"></p><h2 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h2><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623220352355.png" alt="image-20240623220352355" style="zoom:25%;"><h2 id="二进制日志binlog，记录的是DDL和DML语句"><a href="#二进制日志binlog，记录的是DDL和DML语句" class="headerlink" title="二进制日志binlog，记录的是DDL和DML语句"></a>二进制日志binlog，记录的是DDL和DML语句</h2><p>日志格式：由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看。 </p><ul><li>statement：基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的Sql都会记录在日志文件中</li><li>row：基于行的日志记录，记录的是每一行的数据变更（默认）。</li><li>mixed：混合statement和row两种格式，默认采用statement，在某些特殊情况下会自动切换为row进行记录</li></ul><p>redo log就是为了保证在进行脏页刷新发生错误时 进行数据恢复，从而保证数据的持久性</p><ul><li>缓冲池中的数据页发生了变更，而磁盘中的没有变更，该数据页为脏页，需要把脏页刷新到磁盘当中，是的缓冲区当中的数据和磁盘当中的数据保持一致，脏页数据并不是实时刷新，而是一段时间之后通过后台线程数刷新。</li><li>当对缓冲区的数据进行增删改的时候，把该数据记录到redolog buffer（记录数据页的物理变化），事务提交的时候将redolog buffer刷新到磁盘到中持久化的保存到磁盘文件当中</li><li>当脏页数据刷新到磁盘发生错误时，通过redolog（记录档次错误的变化）恢复</li><li>日志文件是追加的，是顺序磁盘IO高于随机磁盘IO</li><li>当脏页数据顺利刷新后，redolog对应的数据变更也就删除，清理redolog日志</li></ul><h2 id="InnoDB存储引擎的逻辑结构"><a href="#InnoDB存储引擎的逻辑结构" class="headerlink" title="InnoDB存储引擎的逻辑结构"></a>InnoDB存储引擎的逻辑结构</h2><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240624170019918.png" alt="image-20240624170019918"></p><p>内存和磁盘结构</p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240624173900431.png" alt="image-20240624173900431"></p><p>后台线程：将InnoDB存储引擎缓冲池中的数据在合适的时机刷新到磁盘文件当中，AIO异步非阻塞IO</p><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240624174319493.png" alt="image-20240624174319493"></p><h2 id="Redis三种持久化方式："><a href="#Redis三种持久化方式：" class="headerlink" title="Redis三种持久化方式："></a>Redis三种持久化方式：</h2><ul><li><p>快照（snapshotting，RDB）：Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p></li><li><p>只追加文件（append-only file, AOF）以日志的形式记录每个写的操作,将Redis执行过的所有命令记录下来,读的操作不记录,只许追加文件,不可以改写文件,Redis启动的时候会读取该文件重新构建数据</p><ul><li><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略）</p></li><li><pre><code>appendfsync alwaysappendfsync everysecappendfsync no<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * **这 3 种持久化方式的主要区别在于 `fsync` 同步 AOF 文件的时机（刷盘）**</span><br><span class="line"></span><br><span class="line">* RDB 和 AOF 的混合持久化(Redis 4.0 新增)</span><br><span class="line"></span><br><span class="line">47. 缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</span><br><span class="line"></span><br><span class="line">    缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。</span><br><span class="line"></span><br><span class="line">    缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。** 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</span><br><span class="line"></span><br><span class="line">    缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</span><br><span class="line"></span><br><span class="line">48. 使用缓存的时候，我们经常需要对内存中的数据进行**持久化**也就是**将内存中的数据写入到硬盘**中。</span><br><span class="line"></span><br><span class="line">49. `@Autowired` 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</span><br><span class="line"></span><br><span class="line">50. **发生循环依赖**是因为在对 A 中的属性 B 进行注入时，注入的是 B 对象，此时又会去初始化 B 对象，发现 B 又依赖了 A，因此才导致的循环依赖</span><br><span class="line"></span><br><span class="line">​**循环依赖问题是如何通过`@Lazy` 解决的呢？**这里举一个例子，比如说有两个 Bean，A 和 B，他们之间发生了循环依赖，那么 A 的构造器上添加 `@Lazy` 注解之后（延迟 Bean B 的实例化），加载的流程如下：</span><br><span class="line"></span><br><span class="line">- 首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</span><br><span class="line">- 由于在 A 上标注了 `@Lazy` 注解，因此 Spring 会去**创建一个 B 的代理对象**，将这个代理对象注入到 A 中的 B 属性；</span><br><span class="line">- 之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</span><br><span class="line"></span><br><span class="line">通过 `@Lazy` 就解决了循环依赖的注入， 关键点就在于对 A 中的属性 B 进行注入时，注入的是 B 的代理对象，因此不会循环依赖。</span><br><span class="line"></span><br><span class="line">51.`@Transient` 注解用于标记某个实体类字段不会被持久化到数据库中。这个字段在实体类中仅用于临时数据存储，且不应该参与数据库的映射操作。</span><br><span class="line"></span><br><span class="line">52.** Serializable**接口里面是没有抽象方法，标记型接口</span><br><span class="line">**** *一旦实现了这个接口，那么就表示当前的**BusinessDataVO**类可以被序列化*</span><br><span class="line"></span><br><span class="line">53. ### `wait()` 方法</span><br><span class="line"></span><br><span class="line">    当一个线程调用某个对象的 `wait()` 方法时，它会进入该对象的等待池（wait set）中，并放弃该对象的锁（monitor），使得其他线程可以获得该锁并执行。</span><br><span class="line"></span><br><span class="line">    ### `notify()` 方法</span><br><span class="line"></span><br><span class="line">    当一个线程调用某个对象的 `notify()` 方法时，会从该对象的等待池中随机唤醒一个等待该对象的线程，使得该线程能够重新获得该对象的锁并继续执行。</span><br><span class="line"></span><br><span class="line">### `notifyAll()` 方法</span><br><span class="line"></span><br><span class="line">当一个线程调用某个对象的 `notifyAll()` 方法时，会唤醒所有等待该对象的线程。这些被唤醒的线程会竞争重新获得该对象的锁，只有一个线程能成功获得锁并继续执行。</span><br><span class="line"></span><br><span class="line"> 为什么不能直接调用 `run()` 方法</span><br><span class="line"></span><br><span class="line">- **直接调用 `run()` 方法**：只是一个普通的方法调用，不会创建新的线程。方法会在当前线程中运行，直到方法执行完毕。</span><br><span class="line">- **调用 `start()` 方法**：`start()` 方法会创建一个新的线程，并且由 JVM 调用 `run()` 方法，从而实现并发执行。</span><br><span class="line"></span><br><span class="line">## MVCC</span><br><span class="line"></span><br><span class="line">* 当前读：读取的是记录的最新版本，读取时还要保证其他并发食物不能修改当前记录，会对读取的记录加锁。</span><br><span class="line">* 快照读：简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本。有可能是历史数据</span><br><span class="line">  * Read Committed：每次select，都生成一个快照读</span><br><span class="line">  * Repeatable Read：开启事务后第一个select语句才是快照读的地方，**也就是第一个select语句会产生数据的快照，后面select直接读取这个快照就行。**</span><br><span class="line">  * Serializable：快照读会退化为当前读</span><br><span class="line"></span><br><span class="line">* InnoDB对MVCC实现的三个字段：ibd文件是独立表空间文件</span><br><span class="line"></span><br><span class="line">  * 隐藏字段：DB_TRX_ID(Transaction)是自增的、DB_ROLL_PTR(pointer)、DB_ROW_ID(如果一张表有主见就不会出现这个)</span><br><span class="line">  * 分别为**最近修改事务ID**、**回滚指针**、**隐藏字段**</span><br><span class="line">  * ![image-20240708204458165](Java八股.assets/image-20240708204458165.png)</span><br><span class="line">  * ReadView：读视图，是**快照读**SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃事务（为提交的）id，ReadView包含了四个核心字段。</span><br><span class="line"></span><br><span class="line">  ![image-20240708214215536](Java八股.assets/image-20240708214215536.png)</span><br><span class="line"></span><br><span class="line">  ![ ](Java八股.assets/image-20240708214322878.png)</span><br><span class="line"></span><br><span class="line">  * undo.log：不同食物或者相同事物对同一记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表的尾部是最早的旧记录，**当insert的时候**，产生的undo.log日志只在回归时候需要，在事物提交后，可以立即被删除。**当update、delete的时候，产生的undo log日志不仅在回滚的时候需要，在快照读的时候也需要，不会被理解删除。**</span><br><span class="line"></span><br><span class="line">​`undo log` 包含了在事务提交前需要撤销的操作，必须保证这些日志在崩溃后也能够被正确回滚。如果仅仅将 `undo log` 保存在内存中，崩溃时这些日志可能会丢失，从而无法回滚未提交的事务。将 `undo log` 的信息记录到 `redo log` 中，可以确保这些日志在崩溃后也能被恢复。</span><br><span class="line"></span><br><span class="line">* MVCC加锁实现隔离型，redo.log和undo.log用来保证事务的一致性</span><br><span class="line"></span><br><span class="line">55. 事务的四大特性是怎么实现的</span><br><span class="line"></span><br><span class="line">* 原子性：undo.log回滚日志保证事务的原子性。</span><br><span class="line">* 持久性：redo.log，缓冲区中的脏页刷新到磁盘的过程中出现问题，可以通过redo.log来恢复，从而保证数据的持久性。</span><br><span class="line">* 一致性：undo.log+redo.log</span><br><span class="line">* 隔离性：锁+MVCC</span><br><span class="line"></span><br><span class="line">56. insert 操作的记录只对事务本身可见，对其他事务不可见” 这句话意味着：</span><br><span class="line"></span><br><span class="line">- 当一个事务 A 执行 `INSERT` 操作时，插入的记录对事务 A 本身是可见的。</span><br><span class="line">- 但在事务 A 提交之前，其他事务（如事务 B）是看不到这些新插入的记录的。</span><br><span class="line"></span><br><span class="line">## MySQL中的锁：</span><br><span class="line"></span><br><span class="line">* 全局锁：**锁的力度很大，锁太重了**，锁定数据库中的所有表：典型使用场景是**做全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性，mysqldump工具用于备份。在InnoDB引擎中，我们可以在备份时加上参数--single- transaction参数来完成不加锁的一致性数据备份。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;Java八股.assets/image-20240719210154363.png&quot; alt=&quot;image-20240719210154363&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* 表级锁：每次操作锁住整张表，锁定力度大，发生锁冲突的概率最高，并发度最低</span><br><span class="line"></span><br><span class="line">  * **表锁**：表共享读锁和表独占写锁</span><br><span class="line">  * **元数据锁**(meta data lock,MDL)</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;Java八股.assets/image-20240719212737675.png&quot; alt=&quot;image-20240719212737675&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  * **意向锁**</span><br><span class="line"></span><br><span class="line">* 行级锁：每次操作锁住对应的行数据，锁定力度最小，发生锁冲突的概率最低，并发度最高，应用在InnoDB存储引擎中。   **事务、外键、行级锁，MyISAM和InnDB的区别**</span><br><span class="line"></span><br><span class="line">![image-20240723215915667](Java八股.assets/image-20240723215915667.png)</span><br><span class="line"></span><br><span class="line">​InnoDB实现两种行锁，共享锁(S)和排他锁(X)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240723220947133.png&quot; alt=&quot;image-20240723220947133&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240723223216374.png&quot; alt=&quot;image-20240723223216374&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">关于第二点：为啥退化？首先明白，间隙锁锁的是两个值之间的间隙，而临建锁锁的是当前锁的值加上值前面的间隙，所以这里就是18-29之间的间隙锁了，但是29没锁，所以是退化为间隙锁，但是18前面的间隙和18则是临建锁。</span><br><span class="line"></span><br><span class="line">下图是第三点的例子</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240723222829442.png&quot; alt=&quot;image-20240723222829442&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">58. 为什么undo log 的信息也会被记录到 redo log 中？</span><br><span class="line"></span><br><span class="line">**确保undo.log的持久性**，`undo log` 包含了在事务提交前需要撤销的操作，必须保证这些日志在崩溃后也能够被正确回滚。如果仅仅将 `undo log` 保存在内存中，崩溃时这些日志可能会丢失，从而无法回滚未提交的事务。将 `undo log` 的信息记录到 `redo log` 中，可以确保这些日志在崩溃后也能被恢复。</span><br><span class="line"></span><br><span class="line">1. 确保数据一致性和完整性</span><br><span class="line"></span><br><span class="line">在事务处理过程中，数据的一致性和完整性是至关重要的。通过将 `undo log` 的信息记录到 `redo log` 中，数据库系统可以确保在崩溃恢复期间，所有已提交的事务都能够正确地恢复。</span><br><span class="line"></span><br><span class="line">- **Redo log**：用于重做已提交的事务，确保在崩溃恢复后，所有已提交的事务都能正确地反映在数据文件中。</span><br><span class="line">- **Undo log**：用于回滚未提交的事务，支持 MVCC（多版本并发控制），提供一致性读。</span><br><span class="line"></span><br><span class="line">2. 崩溃恢复的需要</span><br><span class="line"></span><br><span class="line">当数据库系统崩溃时，需要通过 `redo log` 来恢复未完成的事务，以确保数据库的一致性。`redo log` 包含了所有已提交和未提交事务的更改，包括 `undo log` 的更改。</span><br><span class="line"></span><br><span class="line">- 崩溃恢复过程</span><br><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  1. **应用 redo log**：在崩溃恢复期间，首先通过 `redo log` 重做所有已提交的事务，这包括重做 `undo log` 的更改。</span><br><span class="line">  2. **回滚未提交事务**：通过 `undo log` 回滚未提交的事务。由于 `undo log` 的更改已经记录在 `redo log` 中，即使在崩溃后，也可以确保 `undo log` 的数据完整性。</span><br><span class="line"></span><br><span class="line">3. 确保 undo log 的持久性</span><br><span class="line"></span><br><span class="line">`undo log` 包含了在事务提交前需要撤销的操作，必须保证这些日志在崩溃后也能够被正确回滚。如果仅仅将 `undo log` 保存在内存中，崩溃时这些日志可能会丢失，从而无法回滚未提交的事务。将 `undo log` 的信息记录到 `redo log` 中，可以确保这些日志在崩溃后也能被恢复。</span><br><span class="line"></span><br><span class="line">4. 实现原理</span><br><span class="line"></span><br><span class="line">在 InnoDB 中，`redo log` 是一种物理日志，记录了数据页的物理更改。而 `undo log` 是一种逻辑日志，记录了每一条数据更改前的状态。当事务修改数据时，以下操作会发生：</span><br><span class="line"></span><br><span class="line">1. **记录 undo log**：在修改数据之前，记录一条 `undo log`，保存数据的旧版本。</span><br><span class="line">2. **修改数据**：执行数据修改操作。</span><br><span class="line">3. **记录 redo log**：记录数据页的物理更改和 `undo log` 的写入操作。</span><br><span class="line"></span><br><span class="line">这种设计确保了在崩溃恢复期间，即使事务未提交，`undo log` 也能被恢复，允许未提交的事务被正确回滚。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">将 `undo log` 的信息记录到 `redo log` 中，主要有以下几个原因：</span><br><span class="line"></span><br><span class="line">- 确保数据一致性和完整性。</span><br><span class="line">- 支持崩溃恢复，能够正确重做和回滚事务。</span><br><span class="line">- 确保 `undo log` 的持久性，防止崩溃后日志丢失。</span><br><span class="line">- 简化了恢复过程，确保所有事务操作（包括未提交的操作）都能被正确处理。</span><br><span class="line"></span><br><span class="line">通过这种设计，数据库系统能够在崩溃后高效、可靠地恢复数据，确保事务的原子性和一致性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 方法引用：</span><br><span class="line"></span><br><span class="line">**把已经有的方法拿过来用，当作函数式接口中抽象方法的方法体**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240722170215676.png&quot; alt=&quot;image-20240722170215676&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">进一步简化Lambda表达式</span><br><span class="line"></span><br><span class="line">静态方法引用（类名::静态方法）：如果Lambda表达式里只是调用一个静态方法，并且前后参数的形式一致，就可以使用静态方法引用</span><br><span class="line"></span><br><span class="line">实例方法引用（对象名::实例方法）：如果Lambda表达式里只是调用一个实例方法，并且前后参数的形式一致，就可以使用静态方法引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240716152918886](Java八股.assets/image-20240716152918886.png)</span><br><span class="line"></span><br><span class="line">特定类型的方法的引用（类型::方法）</span><br><span class="line"></span><br><span class="line">![image-20240716154020237](Java八股.assets/image-20240716154020237.png)</span><br><span class="line"></span><br><span class="line">构造器引用（类名::new）</span><br><span class="line"></span><br><span class="line">如果某个Lambda表达式里只是在创建对象，并且前后参数情况一直，就可以使用构造器引用</span><br><span class="line"></span><br><span class="line">![image-20240716154420648](Java八股.assets/image-20240716154420648.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **Stream流的三类方法**</span><br><span class="line"></span><br><span class="line">![image-20240722145442364](Java八股.assets/image-20240722145442364.png)</span><br><span class="line"></span><br><span class="line">- 获取Stream流</span><br><span class="line"></span><br><span class="line">  - 创建一条流水线,并把数据放到流水线上准备进行操作</span><br><span class="line"></span><br><span class="line">- 中间方法</span><br><span class="line"></span><br><span class="line">  - 流水线上的操作</span><br><span class="line">  - 一次操作完毕之后,还可以继续进行其他操作</span><br><span class="line">  - **filter、limit、skip、distinct、concat、map**</span><br><span class="line">  - ![image-20240722145136003](Java八股.assets/image-20240722145136003.png)</span><br><span class="line"></span><br><span class="line">- 终结方法</span><br><span class="line"></span><br><span class="line">  - 一个Stream流只能有一个终结方法</span><br><span class="line"></span><br><span class="line">  - 是流水线上的最后一个操作</span><br><span class="line"></span><br><span class="line">  - **forEach、count、toArray、collect**</span><br><span class="line"></span><br><span class="line">  - &lt;img src=&quot;Java八股.assets/image-20240722145649333.png&quot; alt=&quot;image-20240722145649333&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  - toArray方法：IntFunction&lt;? extends Object[]&gt;中? extends Object[]`**：表示返回类型是某种 `Object` 数组的子类型</span><br><span class="line"></span><br><span class="line">  - &lt;img src=&quot;Java八股.assets/image-20240722150642848.png&quot; alt=&quot;image-20240722150642848&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  - collect方法，收集到list和set集合比较简单，但是收集到map集合中操作比较难，下面是个例子，**注意：如果我们要收集到Map集合中，键不能重复，负责会报错**，**这个很关键**</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Collectors.toMap()//源码</span><br><span class="line">    public static &lt;T, K, U&gt;</span><br><span class="line">        Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper) &#123;</span><br><span class="line">            return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);</span><br><span class="line">        &#125;</span><br><span class="line">    Function为函数式接口</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722163141817.png" alt="image-20240722163141817" style="zoom:33%;"><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722163558060.png" alt="image-20240722163558060" style="zoom:33%;"></li></ul></li></ul><p><strong>生成Stream流的方式</strong></p><ul><li><p>Collection体系集合</p><p>使用默认方法stream()生成流， default Stream<E> stream() ，并把数据放到流当中</E></p></li><li><p>Map体系集合</p><p>把Map转成Set集合，间接的生成流</p></li><li><p>数组</p><p>通过Arrays中的静态方法stream生成流</p></li><li><p>同种数据类型的多个数据</p><p>通过Stream接口的静态方法of(T… values)生成流</p></li></ul><p>map转换流中的数据类型操作：（中间方法）</p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722162754816.png" alt="image-20240722162754816" style="zoom:33%;"><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722145232077.png" alt="image-20240722145232077" style="zoom:33%;"><h2 id="Sql性能分析"><a href="#Sql性能分析" class="headerlink" title="Sql性能分析"></a>Sql性能分析</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring笔记</title>
      <link href="/2024/05/29/spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/29/spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、spring-概述"><a href="#一、spring-概述" class="headerlink" title="一、spring 概述"></a>一、spring 概述</h1><p>学习网址：<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=17&vd_source=6490e6a4523af5eeda2b4c5dae27592a">https://www.bilibili.com/video/BV1Fi4y1S7ix?p=17&amp;vd_source=6490e6a4523af5eeda2b4c5dae27592a</a></p><p><a href="https://cyborg2077.github.io/2022/08/29/Spring/">https://cyborg2077.github.io/2022/08/29/Spring/</a></p><p>Ioc AOP<strong>简化开发</strong></p><p><em><strong>系统架构：</strong></em></p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240513153538745.png" alt="image-20240513153538745" style="zoom:50%;" /><p>1、<strong>IOC(Inversion of Control)控制反转：</strong>使用对象时，由主动new产生对象转换为由<code>外部</code>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。Spring提供了一个容器，称为<code>IOC容器</code>，用来充当IOC思想中的”外部”。（程序创建对象变为外部创建，这种转移叫做控制反转）</p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240515213226144.png" alt="image-20240515213226144" style="zoom:50%;" /><ul><li><p>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</p></li><li><p>被创建或被管理的对象在IOC容器中统称为<strong>Bean</strong>，IOC容器中放的就是一个个的Bean对象</p></li><li><p><strong>IOC入门</strong>：<code>导入spring的坐标spring-context--&gt;配置bean(bean标签，对应的某个类要管理的对象)--&gt; 获取IoC容器ApplicationContext接口(加载xml配置文件)--&gt;获取bean</code>（getBean(id名字)）</p></li></ul><p>2、<strong>DI(Dependency Injection)依赖注入</strong>，在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</p><ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入 </li><li><strong>DI入门</strong>：<code>删除业务层中使用new方式创建的dao对象--&gt;提供对应的set方法(将Service中需要的Dao对象引入到Service中来 )--&gt;配置server和dao的关系(property标签，name属性表示配置哪一个具体的属性，ref属性表示参照哪一个bean)</code></li></ul><p>我们会发现这两个概念的最终目标就是:充分解耦，具体实现靠:</p><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul><h2 id="1、Bean"><a href="#1、Bean" class="headerlink" title="1、Bean"></a>1、Bean</h2><p>Spring创建bean的时候调用的是无参的构造方法</p><p>实例化方法：1.构造方法实例化bean 2.  使用静态工厂实例化bean 3.使用实例工厂实例化bean (<strong>FactoryBean实例化，重要</strong>)</p><p>bean的生命周期：配置、借口、关闭容器close,registerShutdownHook </p><h2 id="2-DI"><a href="#2-DI" class="headerlink" title="2. DI"></a>2. DI</h2><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240514151404481.png" alt="image-20240514151404481" style="zoom:50%;" /> <p>1、setter注入</p><ul><li>简单类型 ：<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li><li>引用类型 ：<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li></ul><p>2、构造器注入</p><ul><li>简单类型 ：<code> &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; value=&quot;&quot;/&gt;</code></li><li>引用类型 : <code>&lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; ref=&quot;&quot;/&gt;</code></li><li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li></ul><p><strong>建议使用setter注入</strong></p><p>3、依赖自动装配：IOC容器根据bean所依赖的资源在容器中<code>自动查找并注入</code>到bean中的过程称为自动装配</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ul><p>4、集合注入（多种数据注入，数组、List、Set、Map、Properties）</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>数据源对象管理，这里使用Spring的IOC容器来管理Druid 连接池对象和C3P0</p><p>注意：(红字弹幕)Druid在初始化的时候没有加载驱动，所以并不会报错找不到com.mysql.jdbc.Driver ，但是当调用DruidDataSource的getConnection()方法获取连接的时候，也会找不到驱动类二报错。 </p><p>配置写在配置文件中不合适，应该单独抽出去，因此 读取外部配置文件到对应配置中，具体步骤如下：</p><p><code>开启context命名空间--&gt;使用context命名空间，加载指定properties文件--&gt;使用$&#123;&#125;读取加载的属性值</code></p><h2 id="3、核心容器总结"><a href="#3、核心容器总结" class="headerlink" title="3、核心容器总结"></a>3、核心容器总结</h2><p><strong>1、容器相关</strong></p><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类<ul><li>ClassPathXmlApplicationContext(常用)</li><li>FileSystemXmlApplicationContext</li></ul></li></ul><p><strong>2、bean相关</strong></p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240515195405655.png" alt="image-20240515195405655" style="zoom:50%;" /><p><strong>3、依赖注入相关</strong></p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240515195637463.png" alt="image-20240515195637463" style="zoom:50%;" /><h2 id="4、IOC-DI注解"><a href="#4、IOC-DI注解" class="headerlink" title="4、IOC&#x2F;DI注解"></a>4、IOC&#x2F;DI注解</h2><p><strong>1、注解开发定义bean：</strong></p><ul><li>删除原先xml<code>配置文件中的定义bean的配置&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</code></li><li>在BookDaoImpl类上添加<code>@Component</code>注解，也就是将该类配置为bean（注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的。）</li><li>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描，使用component-scan标签(此标签属于context命名空间)，要通过base-package&#x3D;‘’指定类所在的位置</li><li>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository  对应于表现层、业务层还是数据层</code>。</li></ul><p><strong>2、纯注解开发：</strong></p><ul><li><code>@Configuration</code>注解用于设定当前类为配置类(代替原先的applicationContext.XML配置文件)</li><li><code>@ComponentScan</code>注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</li></ul><p><strong>3、注解开发bean作用范围和生命周期</strong> </p><ul><li>作用范围使用@scope(“prototype”&#x2F;“singleton”)单例非单例</li><li>生命周期：@PostConstruct<code>构造方法后运行</code>和@PreDestroy<code>在销毁前运行的方法</code></li><li>非单例不执行destroy吗？？？–多例模式下spring不负责销毁(管理bean的生命周期)，所以没有调用destroy方法。</li></ul><p>4、注解开发<strong>依赖注入</strong></p><ul><li><p>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是写在属性上并将setter方法删除掉。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;#这个入口方法就可以不需要了</span><br><span class="line"><span class="comment">//    public void setBookDao(BookDao bookDao) &#123;</span></span><br><span class="line"><span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"> ----为什么setter方法可以删除呢?</span><br><span class="line">- 自动装配基于反射设计创建对象并通过`暴力反射`为私有属性进行设值</span><br><span class="line">- 普通反射只能获取<span class="keyword">public</span>修饰的内容</span><br><span class="line">- 暴力反射除了获取<span class="keyword">public</span>修饰的内容还可以获取<span class="keyword">private</span>修改的内容</span><br><span class="line">- 所以此处无需提供setter方法</span><br><span class="line"> -----什么是反射？--https:<span class="comment">//www.bilibili.com/video/BV1ke4y1w7yn?p=3&amp;vd_source=6490e6a4523af5eeda2b4c5dae27592a</span></span><br><span class="line"> -反射允许对封装类的字段，方法和构造函数的信息进行编程访问，即获取一个类中的成员变量、成员方法、构造方法获取出来进行操作(获取他们的所有信息)，idea自动提示功能就是使用反射实现的，Ctrl+p提示形参也是反射。 </span><br><span class="line"> -暴力反射：表示临时取消权限校验，例如私有方法不让使用，使用setAccessible()强制使用</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>@Autowired</code>是按照类型注入</li><li>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</li><li>注意:@Qualifier不能独立使用，必须和@Autowired一起使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br></pre></td></tr></table></figure><ul><li>简单类型注入，使用@Value()，用于读取配置文件中的值复制给属性，要使用@PropertySource(“jdbc.properties”)读取配置文件@Value(“${name}”)再使用为某一个属性注入name值</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">Stephen</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span> <span class="comment">//在配置类上添加@PropertySource注解</span></span><br><span class="line"><span class="comment">//如果读取的properties配置文件有多个，可以使用@PropertySource的属性来指定多个,@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;),@PropertySource注解属性中不支持使用通配符*,运行会报错,@PropertySource注解属性中可以把classpath:加上,代表从当前项目的根路径找文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类路径classpath指的是编译后路径即:</span></span><br><span class="line"><span class="comment">//本项目[或模块目录]/target/[项目或模块名]/WEB-INF/classes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原项目中java目录下的文件和recource目录下的文件页都被打包到了此类路径下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如下图： java目录中的文件和recource目录中的文件经过编译后，都会放到WEB-INF/classes目录下：</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>  <span class="comment">//使用@Value读取配置文件中的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210307211303344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzYwNTMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210307211412714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzYwNTMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><p>5、注解开发管理<strong>第三方</strong>bean以及依赖注入</p><ul><li><p><strong>注解开发管理第三方bean</strong></p></li><li><p>使用@Bean配置第三方bean,Bean注解的作用是将方法的返回值作为一个Spring管理的bean对象**–&gt;**如何让这个配置类如何能被Spring配置类加载到(将独立的配置类加入核心配置)，并创建DataSource对象在IOC容器中–&gt;@component扫描式和@import导入式 (推荐此方式)</p></li><li><p>在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办?</p><p>这些资源会有两大类，分别是<code>简单数据类型</code> 和<code>引用数据类型</code>。</p><p>我们要进行第三方bean依赖注入，包含引用类型注入(方法形参)和简单类型注入(成员变量)</p></li></ul><p>6、XML配置比对注解配置</p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240518211423923.png" alt="image-20240518211423923" style="zoom:50%;" /><h2 id="5、Spring整合"><a href="#5、Spring整合" class="headerlink" title="5、Spring整合"></a>5、Spring整合</h2><p>1、Spring整合druid</p><p>2、Spring整合mybatis(将mybatis的配置文件干掉)</p><ul><li>感觉很是复杂 </li><li>![image-20240522105051357](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240522105051357.png)</li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240523155608830.png" alt="image-20240523155608830" style="zoom:50%;" /><p>![image-20240522110518256](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240522110518256.png)</p><p>3、Spring整合junit</p><h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="1、-简介"><a href="#1、-简介" class="headerlink" title="1、  简介"></a>1、  简介</h3><ul><li>AOP(Aspect Oriented Programming)面向切面编程，是一种编程范式，指导开发者如何组织程序结构。</li><li>作用:在不惊动原始设计的基础上为其进行功能增强。</li><li>使用了Spring的AOP，在不惊动(改动)原有设计(代码)的前提下，想给谁添加额外功能就给谁添加。这个也就是Spring的理念：</li><li><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240519133046840.png" alt="image-20240519133046840" style="zoom:50%;" /></li></ul><p>切面：在哪些切入点上执行哪些通知 。</p><ul><li>连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul><li>在SpringAOP中，理解为方法的执行</li></ul></li><li>切入点(Pointcut):匹配连接点的式子<ul><li>在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法<ul><li>一个具体的方法:如com.blog.dao包下的BookDao接口中的无形参无返回值的save方法</li><li>匹配多个方法:所有的save方法&#x2F;所有的get开头的方法&#x2F;所有以Dao结尾的接口中的任意方法&#x2F;所有带有一个参数的方法</li></ul></li><li>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</li></ul></li><li>通知(Advice):在切入点处执行的操作，也就是<strong>共性功能</strong><ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul></li><li>通知类：定义通知的类</li><li>切面(Aspect):描述通知与切入点的对应关系(绑定切入点与通知关系)。</li></ul><h3 id="2、入门案例"><a href="#2、入门案例" class="headerlink" title="2、入门案例"></a>2、入门案例</h3><ul><li>导入坐标–&gt;制作连接点（原始操作，Dao接口及实现类）–&gt;制作共性功能（通知类和通知）–&gt;定义切入点–&gt;绑定切入点和通知的关系（切面）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----------------------定义通知类-----------------------</span><br><span class="line"><span class="comment">//通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。类名和方法名没有要求，可以任意。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------修改如下-----------------------</span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//将通知类配给容器并标识其为切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><span class="comment">//定义切入点，切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span> <span class="comment">//绑定切入点与通知关系，并指定 通知 添加到原始连接点的具体执行位置，@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------配置类文件-----------------------</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启注解格式AOP功能，告诉spring我们使用注解开发的AOP，即启动@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、AOP工作流程"><a href="#3、AOP工作流程" class="headerlink" title="3、AOP工作流程"></a>3、<strong>AOP工作流程</strong></h3><p>———————–整个AOP的实现过程是通过代理模式来进行的———————–</p><ul><li><p><strong>流程一：Spring容器启动</strong></p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li><li>注意此时bean对象还没有创建成功</li></ul></li><li><p><strong>流程二：读取所有切面配置中的切入点</strong></p></li><li><p>流程三：<strong>初始化bean</strong>，判定bean对应的类中的方法是否匹配到任意切入点</p><p>匹配失败，创建原始对象，如<code>UserDao</code></p><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul><p>匹配成功，创建原始对象（<code>目标对象</code>）的<code>代理</code>对象，如:<code>BookDao</code></p><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象(<u><strong>也就是原始功能去掉共性功能对应的类产生的对象</strong></u>)</li><li>因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</li><li>最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强</li></ul></li><li><p><strong>流程四：获取bean执行方法</strong></p><ul><li>获取的bean是原始对象时，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ul><p>下面我们来验证一下容器中是否为代理对象</p><ul><li>如果目标对象中的方法<code>会被增强</code>，那么容器中将存入的是目标对象的<code>代理对象</code></li><li>如果目标对象中的方法<code>不被增强</code>，那么容器中将存入的是目标<code>对象本身</code></li></ul></li><li><p>AOP核心概念：</p></li><li><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul></li></ul><h3 id="4、AOP配置管理"><a href="#4、AOP配置管理" class="headerlink" title="4、AOP配置管理"></a>4、AOP配置管理</h3><ul><li>AOP切入点表达式：<strong>切入点</strong>:要进行增强的方法    <strong>切入点表达式</strong>:要进行增强的方法的描述方式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><ul><li>语法格式：</li></ul><p>由于BookDaoImpl类实现了BookDao接口，那么有如下两种方式来描述(因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//描述方式一：执行com.blog.dao包下的BookDao接口中的无参数update方法 </span></span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.BookDao.update())</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//描述方式二：执行com.blog.dao.impl包下的BookDaoImpl类中的无参数update方法 </span></span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.impl.BookDaoImpl.update())</span><br></pre></td></tr></table></figure><p>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名(参数) 异常名）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> User com.blog.service.UserService.findById(<span class="type">int</span>))</span><br><span class="line">    execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</span><br><span class="line">    <span class="keyword">public</span>:访问修饰符,还可以是<span class="keyword">public</span>，<span class="keyword">private</span>等，可以省略</span><br><span class="line">    User：返回值，写返回值类型</span><br><span class="line">    com.blog.service：包名，多级包使用点连接</span><br><span class="line">    UserService:类/接口名称</span><br><span class="line">    findById：方法名</span><br><span class="line">    <span class="type">int</span>:参数，直接写参数的类型，多个类型用逗号隔开</span><br><span class="line">    异常名：方法定义中抛出指定异常，可以省略</span><br></pre></td></tr></table></figure><ul><li>通配符</li></ul><p><code>*</code>:单个独立的任意符号（<strong>写到参数里，说明这必有一个任意参数</strong>），可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><p><code>+</code>：专用于匹配子类类型</p><ul><li>书写技巧</li></ul><p>描述切入点通常<code>描述接口</code>，而不描述实现类,如果描述到实现类，就出现紧耦合了</p></li><li><p>AOP通知类型</p></li></ul><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p><ul><li><ul><li><p>前置通知@Before</p></li><li><p>后置通知@After</p></li><li><p><code>环绕通知(重点)</code>@Around：环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.blog.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="comment">//使用环绕通知的话，要根据原始方法的返回值来设置环绕通知的返回值，Object类型更通用</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><ul><li>返回后通知(了解)@AfterReturning</li><li>抛出异常后通知(了解)@AfterThrowing</li></ul><h2 id="5、AOP案列：测量业务接口执行效率"><a href="#5、AOP案列：测量业务接口执行效率" class="headerlink" title="5、AOP案列：测量业务接口执行效率"></a>5、AOP案列：测量业务接口执行效率</h2><p>环绕通知记得改返回值类型为Object，更通用</p></li><li><p>这里我省略了，就说一下程序的优化</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">//ProceedingJoinPoint中有一个getSignature()方法来获取签名，然后调用getDeclaringTypeName可以获取类名，getName()可以获取方法名。</span></span><br><span class="line">  <span class="comment">//proceedingJoinPoint描述原来执行方法的对象，因此可以拿到原来方法的信息。</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();  <span class="comment">//一次执行的签名信息，封装了这次的执行过程</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;万次执行 &quot;</span> + typeName + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot; 耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、AOP通知获取数据"><a href="#5、AOP通知获取数据" class="headerlink" title="5、AOP通知获取数据"></a>5、AOP通知获取数据</h3><ul><li><p><strong>获取切入点方法的参数</strong>，所有的通知类型都可以获取参数</p><ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非环绕通知获取方式，在方法上添加JoinPoint，通过JoinPoint来获取参数</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">      <span class="comment">//方法的参数只有一个，为什么获取的是一个数组?---因为参数的个数是不固定的，所以使用数组更通配些。</span></span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ProceedingJoinPoint：适用于环绕通知</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    pjp.proceed()方法是有两个构造方法，分别是:</span><br><span class="line">        proceed()</span><br><span class="line">        proceed(Object[] object)</span><br><span class="line">    调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数</span><br><span class="line">    所以调用这两个方法的任意一个都可以完成功能</span><br><span class="line">    但是当需要修改原始方法的参数时，就只能采用带有参数的方法,如下</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">9421</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>ProceedingJoinPoint是JoinPoint类的子类</strong></li></ul></li><li><p><strong>获取切入点方法返回值</strong>，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究</p><ul><li>返回后通知@AfterReturing</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pt()&quot;, returning = &quot;res&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object res)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>环绕通知@Around</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">9421</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed(args);<span class="comment">//res就是方法的返回值，我们是可以直接获取</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于返回值，只有返回后<code>AfterReturing</code>和环绕<code>Around</code>这两个通知类型可以获取</li></ul><ol><li><p>参数名的问题<br> 赋给returning的值，必须与Object类型参数名一致，上面的代码中均为<code>res</code></p></li><li><p>afterReturning方法参数类型的问题<br> 参数类型可以写成String，但是为了能匹配更多的参数类型，建议写成Object类型</p></li><li><p>afterReturning方法参数的顺序问题<br> 如果存在JoinPoint参数，则必须将其放在第一位，否则运行将报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp,Object res)</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究,对于获取抛出的异常，只有抛出异常后<code>AfterThrowing</code>和环绕<code>Around</code>这两个通知类型可以获取</p><ul><li>抛出异常后通知@AfterThrowing获取异常</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pt()&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span> + throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>环绕通知@Around获取异常</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">9421</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = pjp.proceed(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;<span class="comment">//在catch方法中就可以获取到异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、-百度网盘密码数据兼容处理"><a href="#6、-百度网盘密码数据兼容处理" class="headerlink" title="6、 百度网盘密码数据兼容处理"></a>6、 百度网盘密码数据兼容处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.blog.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((String.class).equals(args[i].getClass()))&#123;</span><br><span class="line">                args[i] = args[i].toString().trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、AOP总结"><a href="#7、AOP总结" class="headerlink" title="7、AOP总结"></a>7、AOP<strong>总结</strong></h3><ol><li><h3 id="AOP核心概念："><a href="#AOP核心概念：" class="headerlink" title="AOP核心概念："></a>AOP核心概念：</h3></li></ol><ul><li>概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式</li><li>作用：在不惊动原始设计的基础上为方法进行功能<code>增强</code></li><li>核心概念<ul><li>代理（Proxy）：SpringAOP的核心本质是采用<code>代理模式</code>实现的</li><li>连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</li><li>切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</li><li>通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</li><li>切面（Aspect）：描述通知与切入点的对应关系</li><li>目标对象（Target）：被代理的原始对象成为目标对象</li></ul></li></ul><ol start="2"><li><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3></li></ol><p>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.itheima.service.*Service.*(..))</span><br></pre></td></tr></table></figure><p>切入点表达式描述通配符：</p><ul><li>作用：用于快速描述，范围描述</li><li><code>*</code>：匹配任意符号（常用）</li><li><code>..</code> ：匹配多个连续的任意符号（常用）</li><li><code>+</code>：匹配子类类型</li></ul><ol start="3"><li><h3 id="五种通知类型"><a href="#五种通知类型" class="headerlink" title="五种通知类型"></a>五种通知类型</h3></li></ol><ul><li>前置通知</li><li>后置通知</li><li>环绕通知（重点）<ul><li>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</li><li>环绕通知可以隔离原始方法的调用执行</li><li>环绕通知返回值设置为Object类型</li><li>环绕通知中可以对原始方法调用过程中出现的异常进行处理</li></ul></li><li>返回后通知</li><li>抛出异常后通知</li></ul><ol start="4"><li><h3 id="通知中获取参数"><a href="#通知中获取参数" class="headerlink" title="通知中获取参数"></a>通知中获取参数</h3></li></ol><ul><li>获取切入点方法的参数，所有的通知类型都可以获取参数<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究<ul><li>抛出异常后通知</li><li>环绕通知</li></ul></li></ul><h3 id="8、Spring事务"><a href="#8、Spring事务" class="headerlink" title="8、Spring事务"></a>8、Spring事务</h3><ul><li><p>相关概念：</p></li><li><ul><li>事务作用：在数据层保障一系列的数据库操作同成功同失败</li><li>Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</li><li>银行转账就是一个例子</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在需要被事务管理的方法上添加@Transactional注解</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在JdbcConfig类中配置事务管理器    </span></span><br><span class="line"><span class="comment">//配置事务管理器，mybatis使用的是jdbc事务，</span></span><br><span class="line"><span class="comment">//注意：事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用DataSourceTransactionManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启事务注解@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240519210132332.png" alt="image-20240519210132332" style="zoom:25%;" /><p>Spring注解式事务通常添加在<strong>业务层接口</strong>中而不会添加到<strong>业务层实现类</strong>中，降低耦合</p><p>注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务。</p><ul><li>spring事务角色<ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法，就是transfer方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法，就是acountdao中的两个方法</li></ul></li></ul><p>​                                       <img src="/Users/qh/Library/Application Support/typora-user-images/image-20240519204115739.png" alt="image-20240519204115739" style="zoom:25%;" />        </p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240519204240094.png" alt="image-20240519204240094" style="zoom:25%;" /><ul><li><p>Spring事务属性</p><ul><li>事务配置：这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</li><li>事实上Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>及其子类进行事务回顾，其他的异常类型是不会回滚的，如下面的代码就不会回滚</li></ul><table><thead><tr><th align="center">属性</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">readOnly</td><td align="center">设置是否为只读事务</td><td align="center">readOnly &#x3D; true 只读事务</td></tr><tr><td align="center">timeout</td><td align="center">设置事务超时时间</td><td align="center">timeout &#x3D; -1(永不超时)</td></tr><tr><td align="center">rollbackFor</td><td align="center">设置事务回滚异常(class)</td><td align="center">rollbackFor{NullPointException.class}</td></tr><tr><td align="center">rollbackForClassName</td><td align="center">设置事务回滚异常（String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">noRollbackFor</td><td align="center">设置事务不回滚异常(class)</td><td align="center">noRollbackFor{NullPointExceptior.class}</td></tr><tr><td align="center">noRollbackForClassName</td><td align="center">设置事务不回滚异常(String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">isolation</td><td align="center">设置事务隔离级别</td><td align="center">isolation &#x3D; Isolation. DEFAULT</td></tr><tr><td align="center">propagation</td><td align="center">设置事务传播行为</td><td align="center"></td></tr></tbody></table><ul><li>事务传播行为：事务协调员对事务管理员所携带事务的处理态度。</li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240519210635994.png" alt="image-20240519210635994" style="zoom:33%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><span class="comment">//运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。不鸟他事务管理员，自己另开事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        logDao.log(out + <span class="string">&quot;向&quot;</span> + in + <span class="string">&quot;转账&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><hr><hr><h1 id="二、SpringMVC"><a href="#二、SpringMVC" class="headerlink" title="二、SpringMVC"></a>二、SpringMVC</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><ul><li><p>SpringMVC是隶属于Spring框架的一部分，主要是用来进行Web开发，是对Servlet进行了封装。</p></li><li><p>SpringMVC是一种表现层框架技术，替换原先的servlet技术</p></li><li><p>MVC（Model–View–Controller）模式是软件工程中的一种软件架构模式，它把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p></li><li><p>数据层采用Mybatis框架，表现层采用SpringMVC框架，SpringMVC主要负责的内容是</p></li><li><ul><li>controller如何接收请求和数据</li><li>如何将请求和数据转发给业务层</li><li>如何将响应数据转换成JSON发挥到前端</li></ul></li></ul><p>![image-20240521134959690](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240521134959690.png)</p><ul><li>MVC概念</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> model层</span><br><span class="line">  model层即数据库实体层，也被称为entity层，pojo层。</span><br><span class="line">  一般数据库一张表对应一个实体类，类属性同表字段一一对应。</span><br><span class="line">1.1. dao层</span><br><span class="line">  dao层即数据持久层，也被称为mapper层。持久层就是负责将数据保存到数据库的那一层代码</span><br><span class="line">  dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。</span><br><span class="line"></span><br><span class="line">1.2 service层</span><br><span class="line">  service层即业务逻辑层。</span><br><span class="line">  service层的作用为完成功能设计。</span><br><span class="line">  service层调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> controller层</span><br><span class="line"></span><br><span class="line">controller层即控制层。</span><br><span class="line">controller层的功能为请求和响应控制。</span><br><span class="line">controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。</span><br><span class="line"></span><br><span class="line">javaEE三层架构：表现层、业务层、持久层</span><br><span class="line">mybatis就是持久层框架，简化JDBC开发 </span><br><span class="line">mapper代理开发让mybatis更加简单</span><br></pre></td></tr></table></figure><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240521151934258.png" alt="image-20240521151934258" style="zoom:50%;" /><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240525171902770.png" alt="image-20240525171902770" style="zoom:50%;" />   <img src="/Users/qh/Library/Application Support/typora-user-images/image-20240525173720661.png" alt="image-20240525173720661" style="zoom:50%;" /><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240525180139254.png" alt="image-20240525180139254" style="zoom:50%;" /><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240525182910303.png" alt="image-20240525182910303" style="zoom:50%;" /><p>mybatis有两种参数占位符：</p><ol><li>#{}:会将其替换为？，为了防止SQL注入。</li><li>${}：拼sql，会存在sql注入问题。</li><li>使用时机：</li></ol><ul><li>参数传递的时候：#{}</li><li>表名或者列名不固定的情况下:${}.  也会存在sql注入问题。</li></ul><p>参数类型：parameterType ：可以省略，从对应的接口传过来，接口的形参一般就定义参数类型了</p><p>特殊字符处理：例如xml不能用&lt;小于号，两种处理，<strong>转义字符</strong>和<strong>CDATA区</strong></p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240525185547128.png" alt="image-20240525185547128" style="zoom:50%;" /><p>mybatis对动态sql有很大支撑，使用标签<if></if>,使用<where>标签替换where关键字，避免and问题。</p><p>使用注解开发后，不需要再使用XML文件，直接在对应接口的上面写上sql语句的查询方法就行，<strong>对于一下简单的功能用注解开发，但是太复杂的功能还使用配置文件好点。</strong></p><h2 id="2、-Spring入门案例"><a href="#2、-Spring入门案例" class="headerlink" title="2、 Spring入门案例"></a>2、 Spring入门案例</h2><ul><li><p>SpringMVC流程</p></li><li><p>创建web工程(Maven结构)</p></li><li><p>设置tomcat服务器，加载web工程(tomcat插件)</p></li><li><p>导入坐标(SpringMVC+Servlet)</p></li><li><p>定义处理请求的功能类(UserController)</p></li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建SpringMVC控制类，定义Controller，使用@Controller定义Bean</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//设置当前控制器方法的访问路径，使用@RequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">//设置当前对象的返回值类型（设置当前控制器方法响应内容为当前返回值，无需解析）</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;SpringMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置请求映射(配置映射关系)</li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的Bean</span></span><br><span class="line"><span class="comment">//创建SpringMVC的配置文件，加载controller对应的bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将SpringMVC设定加载到Tomcat容器中</li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个servlet容器的配置类，在里面加载Spring的配置，继承AbstractDispatcherServletInitializer并重写其方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载SpringMvc容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置哪些请求归SpringMvc处理</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">//所有请求都交由SpringMVC处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载Spring容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、工作流程"><a href="#3、工作流程" class="headerlink" title="3、工作流程"></a>3、工作流程</h2><h3 id="启动服务器初始化过程"><a href="#启动服务器初始化过程" class="headerlink" title="启动服务器初始化过程"></a>启动服务器初始化过程</h3><ol><li>服务器启动，执行ServletContainerInitConfig类，初始化web容器</li><li>执行createServletApplicationContext方法，创建了WebApplicationContext对象</li><li>加载SpringMvcConfig配置类</li><li>执行<code>@ComponentScan</code>加载对应的bean<ul><li>扫描指定包及其子包下所有类上的注解，如Controller类上的<code>@Controller</code>注解</li></ul></li><li>加载<code>UserController</code>，每个<code>@RequestMapping</code>的名称对应一个具体的方法<ul><li>此时就建立了 <code>/save</code> 和 <code>save()</code>方法的对应关系(执行&#x2F;save请求会被拦截在save()方法中)</li></ul></li><li>执行<code>getServletMappings</code> 方法，设定SpringMVC拦截请求的路径规则<ul><li><code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h3><ol><li><p>发送请求<code>http://localhost:8080/save</code></p></li><li><p>web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</p></li><li><p>解析请求路径&#x2F;save</p></li><li><p>由</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/save</span><br></pre></td></tr></table></figure><p>匹配执行对应的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save()</span><br></pre></td></tr></table></figure><ul><li>上面的第5步已经将请求路径和方法建立了对应关系，通过<code>/save</code>就能找到对应的<code>save()</code>方法</li></ul></li><li><p>执行<code>save()</code></p></li><li><p>检测到有<code>@ResponseBody</code>直接将<code>save()</code>方法的返回值作为响应体返回给请求方</p></li></ol><h2 id="4、-bean加载控制"><a href="#4、-bean加载控制" class="headerlink" title="4、 bean加载控制"></a>4、 bean加载控制</h2><ul><li><p>SpringMVC</p><p>控制的bean</p><ul><li>表现层bean,也就是<code>controller</code>包下的类</li></ul></li><li><p>Spring</p><p>控制的bean</p><ul><li>业务bean(<code>Service</code>)</li><li>功能bean(<code>DataSource</code>,<code>SqlSessionFactoryBean</code>,<code>MapperScannerConfigurer</code>等)</li></ul></li><li><p><strong>加载Spring控制的bean的时候，<code>排除掉</code>SpringMVC控制的bean</strong></p><ul><li>方式一:Spring加载的bean设定扫描范围为com.itheima,排除掉controller包中的bean</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&quot;com.itheima&quot;,</span></span><br><span class="line"><span class="meta">excludeFilters=@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">classes = Controller.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二:Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试controller类是否被排除掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">System.out.println(ctx.getBean(UserController.class));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:测试的时候，需要把SpringMvcConfig配置类上的@ComponentScan注解注释掉，否则不会<br>报错，出现问题的原因（SpringConfig在设定扫描时如果某一个类上有@Configuration, 那么这个类也会被扫描同时也会加载他的bean）也即是springconfig排除了controller包，但是springconfig会扫到SpringMVCconfig，而SpringMVCconfig会扫到controller，所以白过滤了</p><ul><li>Spring配置类扫描的包是<code> com.itheima</code></li><li>SpringMVC的配置类，<code>SpringMvcConfig</code>上有一个<code>@Configuration</code>注解，也会被Spring扫描到</li><li>SpringMvcConfig上又有一个<code>@ComponentScan</code>，把controller类又给扫描进来了</li><li>所以如果不把<code>@ComponentScan</code>注释掉，Spring配置类将Controller排除，但是因为扫描到SpringMVC的配置类，又将其加载回来，演示的效果就出不来</li><li><strong>解决方案，也简单，把SpringMVC的配置类移出Spring配置类的扫描范围即可。</strong></li><li>Spring的容器不可以访问SpringMVC的容器，SpringMVC的容器可以访问Spring的容器。</li></ul></li></ul><h2 id="5、请求与响应"><a href="#5、请求与响应" class="headerlink" title="5、请求与响应"></a>5、请求与响应</h2><h3 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span> <span class="comment">//路径前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span> <span class="comment">// 前缀+Save</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ..&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span> <span class="comment">// 前缀+delete == /user/delete</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete ..&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意路径配置的优化进行，加载类上是访问前缀，加载方法上具体名称，当类上和方法上都添加了@RequestMapping注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。  <strong>@RequestMapping注解value属性前面加不加&#x2F;都可以</strong></p><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><ul><li>普通类型：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="comment">//使用@RequestParam注解解决形参与地址参数名不一致</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递name --&gt; &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递age --&gt; &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h3><p>发送请求和参数：<code>localhost:8080/user/pojoParam?name=Helsing&amp;age=1024</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;POJO参数传递user --&gt; &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">output:POJO参数传递user --&gt; User&#123;name=‘Helsing’, age=<span class="number">1024</span>&#125;</span><br><span class="line"></span><br><span class="line">    POJO参数接收，前端GET和POST发送请求数据的方式不变。</span><br><span class="line">    请求参数key的名称要和POJO中属性的名称一致，否则无法封装。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="嵌套POJO类型参数"><a href="#嵌套POJO类型参数" class="headerlink" title="嵌套POJO类型参数"></a>嵌套POJO类型参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&quot;</span> + address +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><ul><li>数组类型参数</li></ul><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数</p><ul><li>集合类型参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List hobbies)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;集合参数传递user --&gt; &quot;</span> + hobbies);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">名称 <span class="meta">@RequestParam</span></span><br><span class="line">类型 形参注解</span><br><span class="line">位置 SpringMVC控制器方法形参定义前面</span><br><span class="line">作用 绑定请求参数与处理器方法形参间的关系</span><br></pre></td></tr></table></figure><h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(Date date1,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date2,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern =&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date3)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date1 --&gt; &quot;</span> + date1);</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date2 --&gt; &quot;</span> + date2);</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date3 --&gt; &quot;</span> + date3);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;date param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="响应JSON数据"><a href="#响应JSON数据" class="headerlink" title="响应JSON数据"></a>响应JSON数据</h3></li></ul><p>对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,“value2”,“value3”,…]）</li></ul><ul><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>SpringMVC接收JSON数据的实现步骤为:</p><ol><li>导入jackson包</li><li>开启SpringMVC注解驱动，在配置类上添加<code>@EnableWebMvc</code>注解</li><li>使用PostMan发送JSON数据</li><li>Controller方法的参数前添加<code>@RequestBody</code>注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启SpringMVC注解支持</span></span><br><span class="line"><span class="comment">//使用@EnableWebMvc，在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后台接收参数，参数前添加@RequestBody</span></span><br><span class="line"><span class="comment">//使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/jsonArrayParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonArrayParam</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; hobbies)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;JSON数组参数传递hobbies --&gt; &quot;</span> + hobbies);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;json array param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RequestBody</code>与<code>@RequestParam</code>区别</p><ul><li>区别<ul><li><code>@RequestParam</code>用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li><code>@RequestBody</code>用于接收json数据【application&#x2F;json】</li></ul></li><li>应用<ul><li>后期开发中，发送json格式数据为主，<code>@RequestBody</code>应用较广</li><li>如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数</li></ul></li></ul><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>默认返回的是页面，加上@ResponseBody会显示字符串，返回对象需要依赖<code>@EnableWebMvc</code>注解和<code>@ResponseBody</code>注解。</p><p><code>HttpMessageConverter</code>接口帮我们实现了对象与JSON之间的转换工作，我们只需要在<code>SpringMvcConfig</code>配置类上加上<code>@EnableWebMvc</code>注解即可。</p><h2 id="6、REST风格"><a href="#6、REST风格" class="headerlink" title="6、REST风格"></a>6、REST风格</h2><h3 id="RESTful入门"><a href="#RESTful入门" class="headerlink" title="RESTful入门"></a>RESTful入门</h3><p>REST，表现形式状态转换，它是一种软件架构<code>风格</code><br> 当我们想表示一个网络资源时，可以使用两种方式：</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code></li><li><code>http://localhost/user</code></li></ul></li></ul><p>反观REST风格的描述，请求地址变简洁了，而且只看请求<code>URL</code>并不很容易能猜出来该<code>URL</code>的具体功能</p><p>一个相同的<code>URL</code>地址既可以是增加操作，也可以是修改或者查询，那么我们该如何区分该请求到底是什么操作呢？</p><ul><li><p>按照REST风格访问资源时，使用<code>行为动作</code></p><p>区分对资源进行了何种操作</p><ul><li><code>http://localhost/users</code> 查询全部用户信息 <code>GET</code>（查询）</li><li><code>http://localhost/users/1</code> 查询指定用户信息 <code>GET</code>（查询）</li><li><code>http://localhost/users</code> 添加用户信息 <code>POST</code>（新增&#x2F;保存）</li><li><code>http://localhost/users</code> 修改用户信息 <code>PUT</code>（修改&#x2F;更新）</li><li><code>http://localhost/users/1</code> 删除用户信息 <code>DELETE</code>（删除）</li><li>REST中规定<code>GET</code>&#x2F;<code>POST</code>&#x2F;<code>PUT</code>&#x2F;<code>DELETE</code>针对的是查询&#x2F;新增&#x2F;修改&#x2F;删除，但如果我们非要使用<code>GET</code>请求做删除，这点在程序上运行是可以实现的</li></ul></li></ul><ul><li><strong>根据REST风格对资源进行访问称为<code>RESTful</code></strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span><span class="comment">//使用method属性限定该方法的访问方式为POST，如果使用GET请求将报错</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user save ...&quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在的删除方法没有携带所要删除数据的id，所以针对RESTful的开发，如何携带数据参数?</p><ul><li>修改@RequestMapping的value属性，将其中修改为<code>/users/&#123;id&#125;</code>，目的是和路径匹配</li><li>在方法的形参前添加<code>@PathVariable</code>注解</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送DELETE请求访问localhost:8080/users/9421</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user delete ...&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台输出如下</span></span><br><span class="line">  <span class="comment">//  user delete …9421</span></span><br></pre></td></tr></table></figure><p>疑问：如果方法形参的名称和路径<code>&#123;&#125;</code>中的值不一致，该怎么办?<br> 例如<code>&quot;/users/&#123;id&#125;&quot;</code>和<code>delete(@PathVariable Integer userId)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//如果这两个值不一致，就无法获取参数，此时我们可以在注解后面加上属性，让注解的属性值与&#123;&#125;中的值一致即可</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer userId)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user delete ...&quot;</span> + userId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别</p><ul><li><code>@RequestParam</code>用于接收url地址传参或表单传参</li><li><code>@RequestBody</code>用于接收JSON数据</li><li><code>@PathVariable</code>用于接收路径参数，使用{参数名称}描述路径参数</li></ul><h3 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h3><p>做完了上面的<code>RESTful</code>的开发，就感觉好麻烦，主要体现在以下三部分</p><ul><li>每个方法的<code>@RequestMapping</code>注解中都定义了访问路径<code>/users</code>，重复性太高。<ul><li>解决方案：将<code>@RequestMapping</code>提到类上面，用来定义所有方法共同的访问路径。</li></ul></li><li>每个方法的<code>@RequestMapping</code>注解中都要使用method属性定义请求方式，重复性太高。<ul><li>解决方案：使用<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>代替</li></ul></li><li>每个方法响应json都需要加上<code>@ResponseBody</code>注解，重复性太高。<ul><li>解决方案：<ul><li>将<code>@ResponseBody</code>提到类上面，让所有的方法都有<code>@ResponseBody</code>的功能</li><li>使用<code>@RestController</code>注解替换<code>@Controller</code>与<code>@ResponseBody</code>注解，简化书写</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化后的代码</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer userId, <span class="meta">@PathVariable</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete ...&quot;</span> + userId + <span class="string">&quot;:&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping()</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user update ...&quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user update&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getById ...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getById&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getAll ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RESTful案例"><a href="#RESTful案例" class="headerlink" title="RESTful案例"></a>RESTful案例</h3><p>这里主要说一下直接在浏览器通过<a href="http://localhost:8080/pages/book.html%E8%AE%BF%E9%97%AEpage%E9%A1%B5%E9%9D%A2%E4%BC%9A%E6%8A%A5404%EF%BC%8C%E4%B8%BA%E5%95%A5%EF%BC%9F">http://localhost:8080/pages/book.html访问page页面会报404，为啥？</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为SpringMvcConfig会拦截所有资源路径</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方案：SpringMVC需要将静态资源进行放行</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/xxx时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SpringMvcSupport该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//将我们刚刚写的配置类也扫描进去</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.blog.controller&quot;,&quot;com.blog.config&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态资源访问不要过MVC应该放行 </p><hr><hr><hr><h2 id="7、SSM整合"><a href="#7、SSM整合" class="headerlink" title="7、SSM整合"></a>7、SSM整合</h2><p><a href="https://cyborg2077.github.io/2022/09/10/SSMIntegration/">https://cyborg2077.github.io/2022/09/10/SSMIntegration/</a></p><p>业务层接口测试使用junit测试，而表现层接口使用postman测试。</p><p>static表示该字段是类变量（也称为静态变量），而不是实例变量。静态变量属于类本身，而不是类的某个实例。这意味着可以通过类名直接访问该字段，而不需要创建类的实例。</p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240522205824552.png" alt="image-20240522205824552" style="zoom:50%;" /><p> IDEA使用Tomcat</p><ul><li>集成本地Tomcat</li><li>Tomcat Maven插件</li></ul><p>dao中没有包，因为开发mybatis使用自动代理的方式创建实现类，所以没有impl包</p><p>各个层级均出现异常，异常处理代码书写在哪一层？–所有的异常均抛出到表现层进行处理</p><hr><hr><hr><h2 id="8、拦截器"><a href="#8、拦截器" class="headerlink" title="8、拦截器"></a>8、拦截器</h2><h2 id="拦截器入门"><a href="#拦截器入门" class="headerlink" title="拦截器入门"></a>拦截器入门</h2><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行</p><ul><li>作用：<ul><li>在指定的方法调用前后执行预先设定的代码</li><li>阻止原始方法的执行</li></ul></li><li><code>总结：</code>拦截器就是用来作增强</li></ul><p>但是这个拦截器貌似跟我们之前学的过滤器很像啊，不管是从作用上来看还是从执行顺序上来看</p><ul><li>那么拦截器和过滤器之间的区别是什么呢？<ul><li><code>归属不同：</code>Filter属于Servlet技术，而Interceptor属于SpringMVC技术</li><li><code>拦截内容不同：</code>Filter对所有访问进行增强，Interceptor仅对SpringMVC的访问进行增强</li></ul></li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240526141816847.png" alt="image-20240526141816847" style="zoom:50%;" /><p>当有拦截器后，请求会先进入<code>preHandle</code>方法，</p><ul><li>如果方法返回<code>true</code>，则放行继续执行后面的handle(Controller的方法)和后面的方法</li><li>如果返回<code>false</code>，则直接跳过后面方法的执行。</li></ul><h2 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">包含参数：</span></span><br><span class="line"><span class="comment">    request:请求对象</span></span><br><span class="line"><span class="comment">    response:响应对象</span></span><br><span class="line"><span class="comment">    handler:被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装，可以使用这个调用我们所调用book方法的信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始方法调用后执行的内容</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整</span></span><br><span class="line"><span class="comment">因为我们现在都是返回json数据，所以该参数的使用率不高。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始方法调用完成后执行的内容</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</span></span><br><span class="line"><span class="comment">因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240526144018608.png" alt="image-20240526144018608" style="zoom:50%;" /><h1 id="三、Maven进阶"><a href="#三、Maven进阶" class="headerlink" title="三、Maven进阶"></a>三、Maven进阶</h1><p><a href="https://cyborg2077.github.io/2022/09/13/MavenSenior/">https://cyborg2077.github.io/2022/09/13/MavenSenior/</a></p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240526160203255.png" alt="image-20240526160203255" style="zoom:50%;" /><p>![image-20240526160119680](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240526160119680.png)</p><h2 id="1、分模块开发"><a href="#1、分模块开发" class="headerlink" title="1、分模块开发"></a>1、分模块开发</h2><ul><li>按照功能拆分</li></ul><p>银行项目，手机端、网页端分为两个</p><ul><li>按照模块拆分</li></ul><p>将项目按照一个模块拆分，比如订单和商品席位两个模块，可以使用导入坐标的形式来使用需要的模块</p><p>在<code>maven_01_ssm</code>项目的pom.xml添加<code>maven_02_pojo</code>的依赖，再使用maven_02_pojo前我们需要把这个项目安装到本地的maven仓库中，使用install命令安装成jar包，才能被其他模块导入。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_02_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、依赖管理"><a href="#2、依赖管理" class="headerlink" title="2、依赖管理"></a>2、依赖管理</h2><p><strong>依赖</strong>:指当前项目运行所需的jar一个项目可以设置多个依赖。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>依赖传递:<ul><li>直接依赖</li><li>间接依赖</li><li>因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，具体什么是冲突？Maven是如何解决冲突的？<ul><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</li><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高。<ul><li>A通过B间接依赖到E1</li><li>A通过C间接依赖到E2</li><li>A就会间接依赖到E1和E2，Maven会按照层级来选择，E1是2度，E2是3度，所以最终会选择E1</li></ul></li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。<ul><li>A通过B间接依赖到D1</li><li>A通过C间接依赖到D2</li><li>D1和D2都是两度，这个时候就不能按照层级来选择，需要按照声明来，谁先声明用谁，也就是说B在C之前声明，这个时候使用的是D1，反之则为D2</li></ul></li></ul></li></ul></li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240526194132455.png" alt="image-20240526194132455" style="zoom:50%;" /><ul><li>可选依赖<ul><li>可选依赖指对外隐藏当前所依赖的资源—<code>不透明</code></li><li>在<code>maven_03_dao</code>的pom.xml，在引入<code>maven_02_pojo</code>的时候，添加<code>optional</code></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_02_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>排除依赖<ul><li>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—<code>不需要</code></li><li>前面我们已经通过可选依赖实现了阻断<code>maven_02_pojo</code>的依赖传递，对于排除依赖，则指的是已经有依赖的事实，也就是说<code>maven_01_ssm</code>项目中已经通过依赖传递用到了<code>maven_02_pojo</code>，此时我们需要做的是将其进行排除，所以接下来需要修改<code>maven_01_ssm</code>的pom.xml</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里可以排除多个依赖，只要你有需求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_02_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>总结一下</strong>：</p><ul><li><code>A依赖B，B依赖C</code>，<code>C</code>通过依赖传递会被<code>A</code>使用到，现在要想办法让<code>A</code>不去依赖<code>C</code></li><li>可选依赖是在B上设置<code>&lt;optional&gt;</code>，<code>A</code>不知道有<code>C</code>的存在，</li><li>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>，<code>A</code>知道有<code>C</code>的存在，主动将其排除掉。</li></ul><h2 id="3、聚合和继承"><a href="#3、聚合和继承" class="headerlink" title="3、聚合和继承"></a>3、聚合和继承</h2><h3 id="1-聚合："><a href="#1-聚合：" class="headerlink" title="1.聚合："></a>1.聚合：</h3><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240526195159077.png" alt="image-20240526195159077" style="zoom:50%;" /><ul><li><p>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</p></li><li><p>聚合工程：通常是一个不具有业务功能的<code>空</code>工程</p></li><li><p>作用：使用聚合工程可以将多个工程编组，通过对聚合工程的构建，实现对所包含的所有模块进行同步构建</p><ul><li>当工程中某个模块发生更新后，必须保障工程中与更新模块关联的模块同步更新，此时就可以使用聚合工程来解决批量模块同步构建的问题</li></ul></li><li><p><code>步骤一：</code>创建一个空的maven项目</p></li><li><p><code>步骤二：</code>将项目打包方式改为<code>pom</code></p></li><li><p><code>步骤三</code>pom.xml添加所要管理的项目</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_00_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置打包方式--&gt;</span></span><br><span class="line">  说明:项目的打包方式，我们接触到的有三种，分别是</span><br><span class="line">    jar:默认情况，说明该项目为java项目</span><br><span class="line">    war:说明该项目为web项目</span><br><span class="line">    pom:说明该项目为聚合或继承(后面会讲)项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置管理的项目名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_01_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>步骤四：</code>使用聚合统一管理项目<br> 在maven面板上点击compile，会发现所有受管理的项目都会被执行编译，这就是聚合工程的作用</li></ul><p>说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。虽然我们配置的顺序是<code>123</code>，但是执行的时候按照依赖关系编译是<code>231</code></p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><ul><li><code>spring-webmvc</code>、<code>spring-jdbc</code>在三个项目模块中都有出现，这样就出现了重复的内容</li><li><code>spring-test</code>只在ssm_crm和ssm_goods中出现，而在ssm_order中没有，这里是部分重复的内容</li><li>我们使用的spring版本目前是<code>5.2.10.RELEASE</code>，假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高</li></ul><p>面对上面这些问题，我们就得用到接下来要学习的<code>继承</code></p><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承类似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p><code>步骤一：</code>创建一个空的Maven项目并将其打包方式设置为pom</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_00_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置打包方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>步骤二：</code>在子工程中设置其父工程</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_00_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置父项目的pom.xml路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_00_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>步骤三：</code>优化子项目共有依赖导入问题</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_00_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置打包方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置管理的项目名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_01_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除子项目中已经被抽取到父项目的pom.xml中的jar包</p><ul><li>删除完后，你会发现父项目中有依赖对应的jar包，子项目虽然已经将重复的依赖删除掉了，但是刷新的时候，子项目中所需要的jar包依然存在。</li><li>当项目的<code>&lt;parent&gt;</code>标签被移除掉，会发现多出来的jar包依赖也会随之消失。</li><li>在父项目中修改jar包的版本，刷新后，子项目中的jar包版本也随之变化</li></ul><p>有一些jar不是所有的子工程都有，对不需要他们的直接继承父工程会加重他们的负担，因此在父工程中使用<dependencyManagement></dependencyManagement>定义依赖管理，形成可选依赖。</p><p>具体过程：</p><ul><li>在父工程中的pom.xml中定义依赖管理</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>将maven_01_ssm的pom.xml中的junit依赖删除掉，刷新Maven刷新后，在maven_01_ssm项目中找不到junit依赖，所以我们得出一个结论<code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code></li><li>在maven_01_ssm的pom.xml添加junit的依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意：这里就不需要添加版本了，这样做的好处就是当父工程dependencyManagement标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化--&gt;</span></span><br></pre></td></tr></table></figure><p>总结一下：</p><ol><li>子工程中使用父工程中的可选依赖时，仅需要提供群组id和项目id，无需提供版本，版本由父工程统一提供，避免版本冲突</li><li>子工程中还可以定义父工程中没有定义的依赖关系,只不过不能被父工程进行版本统一管理。</li></ol><h3 id="3-聚合和继承的区别"><a href="#3-聚合和继承的区别" class="headerlink" title="3.聚合和继承的区别"></a>3.聚合和继承的区别</h3><p>聚合与继承分别的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h2 id="4、属性"><a href="#4、属性" class="headerlink" title="4、属性"></a>4、属性</h2><p>定义变量来代替直接写jar包的版本号，修改可以更简单且修改时不会漏</p><p>使用<code>properties</code>标签来定义属性，在<code>properties</code>标签内自定义标签名当做属性名，自定义标签内的值即为属性值。<br> 例如：<code>&lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</code>，属性名为<code>spring.version</code>，属性值为<code>5.2.10.RELEASE</code>在其他地方引用变量时用<code>$&#123;变量名&#125;</code></p><p>配置文件也能加载属性</p><h2 id="5、多环境配置与应用"><a href="#5、多环境配置与应用" class="headerlink" title="5、多环境配置与应用"></a>5、多环境配置与应用</h2><h3 id="1-多环境开发"><a href="#1-多环境开发" class="headerlink" title="1.多环境开发"></a>1.多环境开发</h3><p>父工程配置多个环境，并指定默认激活环境</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-跳过测试"><a href="#2-跳过测试" class="headerlink" title="2.跳过测试"></a>2.跳过测试</h3><ul><li><code>方式一：</code>IDEA工具实现跳过测试<br> IDEA的maven面板上有一个按钮，点击之后可以跳过测试，不过此种方式会跳过所有的测试，如果我们想更精细的控制哪些跳过，哪些不跳过，那么就需要使用配置插件的方式来完成了</li><li><code>方式二：</code>配置插件实现跳过测试<br> 在父工程中的pom.xml中添加测试插件配置</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除掉不参与测试的内容--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/BookServiceTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">              skipTests：如果为true，则跳过所有测试，如果为false，则不跳过测试</span><br><span class="line">              excludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的</span><br><span class="line">              includes：哪些测试类要参与测试，即包含,针对skipTests为true来设置的</span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>方式三：</code>命令行跳过测试<br> 使用Maven的命令行，<code>mvn 指令 -D skipTests</code></li></ul><h2 id="6、私服"><a href="#6、私服" class="headerlink" title="6、私服"></a>6、私服</h2><p>所有私服仓库总共分为三大类:</p><ol><li>宿主仓库hosted<ul><li>保存无法从中央仓库获取的资源</li><li>自主研发</li><li>第三方非开源项目,比如Oracle,因为是付费产品，所以中央仓库没有</li></ul></li><li>代理仓库proxy<ul><li>代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库</li></ul></li><li>仓库组group<ul><li>将若干个仓库组成一个群组，简化配置</li><li>仓库组不能保存资源，属于设计型仓库</li></ul></li></ol><table><thead><tr><th align="center">仓库类别</th><th align="center">英文名称</th><th align="center">功能</th><th align="center">关联操作</th></tr></thead><tbody><tr><td align="center">宿主仓库</td><td align="center">hosted</td><td align="center">保存自主研发+第三方资源</td><td align="center">上传</td></tr><tr><td align="center">代理仓库</td><td align="center">proxy</td><td align="center">代理连接中央仓库</td><td align="center">下载</td></tr><tr><td align="center">仓库组</td><td align="center">group</td><td align="center">为仓库编组简化下载操作</td><td align="center">下载</td></tr></tbody></table><h1 id="四、SpringBoot简介"><a href="#四、SpringBoot简介" class="headerlink" title="四、SpringBoot简介"></a>四、SpringBoot简介</h1><ul><li><p>Springboot项目不用在依赖tomcat，它内置tomcat因此将它打包后使用java -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar可以直接运行。</p></li><li><p>springboot概述</p><ul><li>起步依赖：<ul><li>starter，<code>SpringBoot</code> 中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的，</li><li>parent，所有 <code>SpringBoot</code> 项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的</li></ul></li><li>程序启动：直接运行Springboot程序的引导类。</li><li>切换web服务器，</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          而要切换 web 服务器就需要将默认的 tomcat 服务器给排除掉，怎么排除呢？需要用到我们前面学的知识排除依赖，使用 exclusion 标签</span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">还要引入 jetty 服务器。</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置文件：三种</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml</li><li>注意：<code>SpringBoot</code> 程序的配置文件名必须是 <code>application</code> ，只是后缀名不同而已。</li><li>三种配置文件的优先级是：<code>application.properties</code>  &gt;  <code>application.yml</code>   &gt;  <code>application.yaml</code></li><li>YAML 文件扩展名：<ul><li><code>.yml</code> (主流)</li><li><code>.yaml</code></li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格<strong>（不允许使用Tab键）</strong>，空格的个数并不重要，只要保证同层级的左侧对齐即可。</li><li>属性层级关系使用多行描述，每行结尾使用冒号结束</li></ul></li></ul></li><li><p>多环境配置</p><ul><li>yaml文件：在 <code>application.yml</code> 中使用 <code>---</code> 来分割不同的配置</li><li>properties文件：properties<code> 类型的配置文件配置多环境需要</code>定义不同的配置文件，如application-dev.properties开发环境、application-test.properties测试环境、application-pro.properties生产环境</li><li><code>SpringBoot</code> 只会默认加载名为 <code>application.properties</code> 的配置文件，所以需要在 <code>application.properties</code> 配置文件中设置启用哪个配置文件，配置如下:</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">pro</span></span><br></pre></td></tr></table></figure></li><li><p>命令行启动参数设置</p><ul><li><code>SpringBoot</code> 提供了在运行 <code>jar</code> 时设置开启指定的环境的方式</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure><p>测试后就会发现命令行设置的端口号优先级高（也就是使用的是命令行设置的端口号），配置的优先级其实 <code>SpringBoot</code> 官网已经进行了说明，详情参见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><p>如果使用了多种方式配合同一个配置项，优先级高的生效。</p></li><li><p>配置文件分类</p><ul><li><code>SpringBoot</code> 中4级配置文件放置位置：级别越高的优先级越高<ul><li>1级：classpath：application.yml</li><li>2级：classpath：config&#x2F;application.yml</li><li>3级：file ：application.yml</li><li>4级：file ：config&#x2F;application.yml</li></ul></li></ul></li><li><p>Springboot整合Junit</p><ul><li><p>在测试类上添加 <code>SpringBootTest</code> 注解</p></li><li><p>使用 <code>@Autowired</code> 注入要测试的资源</p></li><li><p>定义测试方法进行测试</p></li><li><p><strong>注意：这里的引导类所在包必须是测试类所在包及其子包。</strong></p><p>例如：</p><ul><li><strong>引导类所在包是 <code>com.blog</code></strong></li><li><strong>测试类所在包是 <code>com.blog</code></strong></li></ul><p>如果不满足这个要求的话，就需要在使用 <code>@SpringBootTest</code> 注解时，使用 <code>classes</code> 属性指定引导类的字节码对象。如 <code>@SpringBootTest(classes = XxxApplication.class)</code></p></li></ul></li><li><p>Springboot整合MyBatis</p><ul><li>不在使用哪些配置类，SpringConfig配置类、JdbcConfig配置类、MyBatisConfig配置类</li><li>只需要导入依赖MyBatis Framework<code>和</code>MySQL Driver</li><li>但是需要注意，在使用Spring整合Mybatis使用mapper代理开发需要读取dao接口并将其限定为bean，然后由于删除了MyBatisConfig配置类因此就无法将dao接口猪草到spring中。因此需要在接口上添加@Mapper将其注册到spring中去</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Mybatis 会扫描接口并创建接口的代码对象交给 Spring 管理，但是现在并没有告诉 Mybatis 哪个是 dao 接口。而我们要解决这个问题需要在BookDao 接口上使用 @Mapper ，BookDao 接口修改为</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Druid数据源</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">PASSWORD.</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure></li><li><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>在 <code>SpringBoot</code> 程序中是没有 <code>webapp</code> 目录的，那么在 <code>SpringBoot</code> 程序中静态资源需要放在什么位置呢？<br> 静态资源需要放在 <code>resources</code> 下的 <code>static</code> 下</p></li></ul><h1 id="五、spring-boot概述"><a href="#五、spring-boot概述" class="headerlink" title="五、spring boot概述"></a>五、spring boot概述</h1><p>![image-20240511181240677](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240511181240677.png)</p><p>![image-20240511181343995](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240511181343995.png)</p><p>1、创建Maven项目，导入SpringBoot起步依赖，定义Controller，编写引导累，启动测试。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  springboot工程需要继承的父工程，定义了一些版本信息</span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  web开发的起步依赖</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Groupid，artifactid</p><p>2、配置文件包含application.properties、application.yml&#x2F;.yaml格式，统一目录下三个配置文件。优先级顺序一次递减。</p><img src="/Users/qh/Library/Applicat ion Support/typora-user-images/image-20240511203006383.png" alt="image-20240511203006383" style="zoom:50%;" /><p>读取配置文件内容：1.@Value.    2.对象Environment      3.@ConfigureationProperties</p><p>@Autowired</p><p>3、我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如:开发、测试、生产等。其中数据库地址、服务 器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile功能就是来进行动态配置切换的。</p><ul><li><p><strong>需要在application.properties中激活多个profile文件</strong></p><center>  <img src="/Users/qh/Library/Application Support/typora-user-images/image-20240512101808567.png" alt="image-20240512101808567" style="zoom:50%;" />  <img src="/Users/qh/Library/Application Support/typora-user-images/image-20240512103521293.png" style="zoom:50%;" /></center></li><li><p><strong>使用yml文件时，可以放在一个文件中，但需要划分不同的文档。</strong></p><center>  <img src="/Users/qh/Library/Application Support/typora-user-images/image-20240512102157376.png" alt="image-20240512102157376" style="zoom:50%;" />  <img src="/Users/qh/Library/Application Support/typora-user-images/image-20240512102236415.png" alt="image-20240512102236415" style="zoom:50%;" /></center><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240512104032895.png" alt="image-20240512104032895" style="zoom:50%;" /></li><li><p>springboot整合junit(java单元测试框架)</p></li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240513105428611.png" alt="image-20240513105428611" style="zoom:50%;" /><p>​需要注意的是：如果当前测试用例的包跟引导类的包<strong>一样</strong>或者是其<strong>子包</strong> @SpringBootTest(classes &#x3D; SpringbootTestApplication.class)中classes<strong>不需要指定</strong>，即@SpringBootTest</p><p>![image-20240513094526945](&#x2F;Users&#x2F;qh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240513094526945.png)</p><ul><li>springboot整合redis</li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240513105417044.png" alt="image-20240513105417044" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.springbootredis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.BoundValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootRedisApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;<span class="comment">//注入RedisTemplate模板</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>).set(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>).get();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>springboot整合Mybatis</li></ul><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240513105358071.png" alt="image-20240513105358071" style="zoom:50%;" /><p>pom.xml文件中&lt;*scope*&gt;runtime</scope> <em>, runtime</em>表示被依赖项目无需参与项目的编译,不过后期的测试和运行周期需要其参与。</p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240513101129103.png" alt="image-20240513101129103" style="zoom:50%;" /><p>编写dao和<strong>mapper文件&#x2F;纯注解开发</strong>，1.用注解开发就不需要写Mybatis的配置信息了 2.xml(mapper文件  )配置需要<strong>添加配置信息</strong>，没有写select注解意味着要写一个配置文件去映射findAll方法。</p><img src="/Users/qh/Library/Application Support/typora-user-images/image-20240513105310326.png" alt="image-20240513105310326" style="zoom:50%;" /><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.springbootmybatis.mapper.UserXmlMapper&quot;</span>&gt;</span> UserXmlMapper的路径，指定后才能和该xml文件对应 </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mybatis,选择2需要添加该配置信息</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*Mapper.xml</span> <span class="comment"># mapper映射文件路径</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.springbootmybatis.domain</span>  <span class="comment">#别名</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_45188218/article/details/138085639---">https://blog.csdn.net/weixin_45188218/article/details/138085639---</a>   Mapper的注解 @Mapper、@Repository、@MapperScan</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2024/05/16/%E9%9A%8F%E7%AC%94/"/>
      <url>/2024/05/16/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>论文投出去一周，因为方向不一致给拒了，又得开始找期刊投，真麻烦！！！他喵的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2024/05/15/spring/"/>
      <url>/2024/05/15/spring/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载声明：本文转载自 <a href="https://example.com/original-article">原作者名称</a>。本文版权归原作者所有，如有侵权，请联系删除。</p></blockquote><h1 id="示例博客文章标题"><a href="#示例博客文章标题" class="headerlink" title="示例博客文章标题"></a>示例博客文章标题</h1><p>这是转载的文章内容…</p><!-- 添加原文链接和版权信息 --><p>原文链接：<a href="https://example.com/original-article">示例博客文章标题</a></p><p>原作者：原作者名称</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/05/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/13/hello-world/"/>
      <url>/2024/05/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!-- cover: /img/cover/3.png -->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

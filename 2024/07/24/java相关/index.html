<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java相关 | Hungyeye's blog</title><meta name="author" content="Hungyeye"><meta name="copyright" content="Hungyeye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。  存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对">
<meta property="og:type" content="article">
<meta property="og:title" content="java相关">
<meta property="og:url" content="https://hungyeye.github.io/2024/07/24/java%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Hungyeye&#39;s blog">
<meta property="og:description" content="存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。  存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hungyeye.github.io/img/cover/0.PNG">
<meta property="article:published_time" content="2024-07-24T03:40:53.000Z">
<meta property="article:modified_time" content="2024-07-24T05:19:29.490Z">
<meta property="article:author" content="Hungyeye">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hungyeye.github.io/img/cover/0.PNG"><link rel="shortcut icon" href="/img/touxiang.png"><link rel="canonical" href="https://hungyeye.github.io/2024/07/24/java%E7%9B%B8%E5%85%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Hungyeye","link":"链接: ","source":"来源: Hungyeye's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java相关',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-24 13:19:29'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/0.PNG')"><nav id="nav"><span id="blog-info"><a href="/" title="Hungyeye's blog"><span class="site-name">Hungyeye's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java相关</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-24T03:40:53.000Z" title="发表于 2024-07-24 11:40:53">2024-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-24T05:19:29.490Z" title="更新于 2024-07-24 13:19:29">2024-07-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java相关"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ol>
<li><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
</li>
<li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于<strong>堆内存</strong>，局部变量则存在于<strong>栈内存</strong>。</p>
</li>
<li><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240701202652986.png" alt="image-20240701202652986"></p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240701202708263.png" alt="image-20240701202708263"></p>
</li>
<li><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存中</strong>），对象引用指向对象实例（<strong>对象引用存放在栈内存中</strong>）。Student s1 &#x3D; new Student(); – 在占栈内存中声明一个名字为s1的空间存储Student这个类对象的地址值。这行代码虚拟机至少做了7步，虚拟机会自动调用主入口的main方法</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531101956061.png" alt="image-20240531101956061" style="zoom:50%;">
</li>
<li><p>变量里面存储的是真实的数据，数组变量记录的是数组数据在堆内存中存放的的地址值，真实数据在堆内存中存放，虚拟机构成就是这样，<strong>方法区中临时存储的字节码文件。</strong></p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240530112403058.png" alt="image-20240530112403058" style="zoom:50%;">

<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240530112335429.png" alt="image-20240530112335429" style="zoom:50%;">
</li>
<li><p>（GPT提供）在Java中，二维数组的内存空间地址并不是连续的。这是因为Java中的二维数组实际上是一个数组的数组，即一个外层数组，其中每个元素都是一个指向内层数组的引用。具体来说，内存布局如下：</p>
<ol>
<li><strong>外层数组</strong>：<ul>
<li>外层数组的元素存储的是指向内层数组的引用。</li>
<li>这些引用是连续存储的，因为外层数组是一个普通的引用类型数组。</li>
</ul>
</li>
<li><strong>内层数组</strong>：<ul>
<li>每个内层数组本身也是一个独立的数组。</li>
<li>这些内层数组在内存中的位置不一定是连续的，因为它们是独立分配的。</li>
</ul>
</li>
</ol>
</li>
<li><p>（GPT提供）在 Java 中，对象的引用是指存储对象内存地址的变量，而不是对象本身。引用变量用于指向对象，使得我们可以通过引用变量来访问和操作该对象的属性和方法。</p>
<h3 id="对象和对象引用的区别"><a href="#对象和对象引用的区别" class="headerlink" title="对象和对象引用的区别"></a>对象和对象引用的区别</h3><ol>
<li><strong>对象</strong>：对象是类的一个实例，它在内存中占有一定的空间，并包含类定义的属性和方法。</li>
<li><strong>对象引用</strong>：对象引用是一个变量，用于存储对象的内存地址，通过引用变量可以访问对象的属性和方法。</li>
</ol>
</li>
<li><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</li>
</ol>
<p>将字节码文件加载到方法区中，并将main()方法进行临时存储</p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531100935092.png" alt="image-20240531100935092"></p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531101512207.png" alt="image-20240531101512207"></p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240531104232585.png" alt="image-20240531104232585"></p>
<ol start="9">
<li><p>字符串的值不能更改，一旦创建不能更改，<strong>StringTable(串池，字符串常量池 )，用来存储只有<u>直接赋值</u>的方式获取的字符串才存在这个池子中</strong>，JDK7以前都存在方法区，以后存储在<strong>堆内存</strong>中</p>
</li>
<li><ul>
<li><p>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</p>
</li>
<li><p>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</p>
</li>
<li><p>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</p>
</li>
<li><p>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</p>
</li>
</ul>
</li>
<li><p>StringBuilder可以看成一个容器，创建之后里面的内容是可变的，他并不是一个字符串，每次完成操作后还需要变为字符串toString()。</p>
</li>
</ol>
<ul>
<li><p>提高字符串的效率。</p>
</li>
<li><p>一般字符串拼接的时候会用到</p>
</li>
<li><p>字符串反转的时候也会用到</p>
</li>
</ul>
<ol start="12">
<li>&#x3D;&#x3D;</li>
</ol>
<ul>
<li>基本数据类型比较的是数据值</li>
<li>引用数据类型比较的地址值，就是两个变量s1，s2记录的地址值。</li>
</ul>
<ol start="13">
<li>抽象方法所在的类必须是抽象类</li>
</ol>
<ul>
<li><p>抽象类是对一种<strong>事物的抽象</strong>，即对类抽象，接口是一种规则，是对<strong>行为的抽象</strong>，不是表示事物。</p>
</li>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
</li>
</ul>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
<ul>
<li><strong>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</strong>。</li>
</ul>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
<ul>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ul>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<ul>
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。</li>
</ul>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<ul>
<li>抽象类存在的意义是为了被子类继承。</li>
</ul>
<blockquote>
<p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p>
</blockquote>
<ol start="14">
<li>final修饰的变量是引用类型</li>
</ol>
<blockquote>
<p>那么变量存储的<strong>地址值不能发生改变</strong>，对象<strong>内部的可以改变</strong></p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240602155428857.png" alt="image-20240602155428857" style="zoom:50%;">
</blockquote>
<ol start="15">
<li><p>多态：对象的多种形态。一定要有继承&#x2F;实现的关系</p>
<blockquote>
<p>创建对象(多态方式)</p>
<p>Fu f &#x3D; new Zi();</p>
</blockquote>
</li>
</ol>
<p><strong>要注意的是：</strong></p>
<ul>
<li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li>
<li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象。</li>
<li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li>
</ul>
<ol start="16">
<li>不同权限的访问能力</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>默认</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td align="left">√</td>
</tr>
<tr>
<td>同一包中的类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td align="left"></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>√</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td align="left"></td>
</tr>
</tbody></table>
<ol start="17">
<li>二维数组内存图</li>
</ol>
<p>数组的地址值表示：[I@119d7047,[–表示数组，I表示类型(int类型)，@固定类型，119d7047表示真正的地址值</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240602171425025.png" alt="image-20240602171425025" style="zoom:50%;">

<ol start="18">
<li>Java中只有<strong>值传递</strong>，没有引用传递</li>
</ol>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中<strong>地址值的拷贝</strong>，同样也会创建副本。</li>
</ul>
<ol start="19">
<li>Java集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</li>
</ol>
<p>如何选用集合：</p>
<ul>
<li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li>
<li>我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li>
</ul>
<ol start="20">
<li><p>Comparable和Comparator</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604202430664.png" alt="image-20240604202430664" style="zoom:50%;">

<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604202525308.png" alt="image-20240604202525308"></p>
<p>简单理解：</p>
<blockquote>
<p>o1 - o2 :升序排序。o2 - o1:降序排序</p>
</blockquote>
</li>
<li><p>生产者消费者模型 </p>
</li>
<li><p>包装类：基本数据类型对应的引用类型，把基本数据类型变成了对象（crtl+b跟进，ctrl+alt+左键返回）</p>
</li>
</ol>
<ul>
<li>Int类型所对应的包装类为Integer，在java中使用Integer这个类来描述正数。</li>
<li>以前的包装类如何进行计算<ul>
<li>帮对象进行装箱，变成基本数据类型</li>
<li>相加</li>
<li>把得到的结果再次进行装箱（再变回包装类）</li>
<li>JDK5的时候提出了一个机制：自动装箱和自动拆箱</li>
</ul>
</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604170849688.png" alt="image-20240604170849688"></p>
<ol start="23">
<li>JDK(Java Development kit)是java开发工具包，JRE(Java Runtime Environment)是Java运行环境</li>
</ol>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240604172704257.png" alt="image-20240604172704257"></p>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605103946606.png" alt="image-20240605103946606" style="zoom:33%;">

<h3 id="Collection单列集合"><a href="#Collection单列集合" class="headerlink" title="Collection单列集合"></a>Collection单列集合</h3><ul>
<li>如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法。</li>
</ul>
<blockquote>
<p>Collection<Student> Coll &#x3D; new ArrayList&lt;&gt;();</Student></p>
<p>Student是我们的自定义对象</p>
</blockquote>
<p>如果存储的是自定义对象，没有重写equals方法，那么默认使用Object类中的equals方法进行判断，而Object类中equals方法，依赖地址值进行判断。不需要自己写，在Student类中idea生成</p>
<ul>
<li>Collection的遍历方式（在遍历集合的时候不依赖索引，因为他的儿子set没有索引，只有List儿子有）</li>
</ul>
<blockquote>
<p>迭代器遍历、增强for遍历、Lambda表达式遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------迭代器遍历---------------</span></span><br><span class="line"><span class="comment">//Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</span></span><br><span class="line">    Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">    <span class="comment">//用while循环改进元素的判断和获取</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------增强for遍历---------------</span></span><br><span class="line">				<span class="comment">//1,数据类型一定是集合或者数组中元素的类型</span></span><br><span class="line">        <span class="comment">//2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素</span></span><br><span class="line">        <span class="comment">//3,list就是要遍历的集合或者数组</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//---------------Lambda遍历---------------</span></span><br><span class="line">				<span class="comment">//2.利用匿名内部类的形式</span></span><br><span class="line">        <span class="comment">//底层原理：</span></span><br><span class="line">        <span class="comment">//其实也会自己遍历集合，依次得到每一个元素</span></span><br><span class="line">        <span class="comment">//把得到的每一个元素，传递给下面的accept方法</span></span><br><span class="line">        <span class="comment">//s依次表示集合中的每一个数据</span></span><br><span class="line">       <span class="comment">/* coll.forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<h3 id="List中常见的方法和无种遍历方式"><a href="#List中常见的方法和无种遍历方式" class="headerlink" title="List中常见的方法和无种遍历方式"></a>List中常见的方法和无种遍历方式</h3><ul>
<li><p>remove方法有两个，当调用方法的时候，如果方法出现了重载现象，<strong>优先调用</strong>实参跟形参一致的那个方法。</p>
</li>
<li><p>List集合独有<strong>列表迭代器遍历</strong>（额外添加了一个方法，在遍历过程中可以添加元素，collection那个是可以remove元素），<strong>普通for循环</strong>(因为List集合存在索引)</p>
</li>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605103510248.png" alt="image-20240605103510248" style="zoom:33%;"></li>
</ul>
<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240611200840383.png" alt="image-20240611200840383" style="zoom:33%;">

<p>考虑了两种情况</p>
<ul>
<li>添加第一个元素</li>
<li>添加第一个元素时，底层创建呢的新的长度为10的数组装满的情况，要装第十一元素了</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240611200709767.png" alt="image-20240611200709767"></p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240611200639523.png" alt="image-20240611200639523"></p>
<h3 id="Set系列集合-无序、不重复、无索引"><a href="#Set系列集合-无序、不重复、无索引" class="headerlink" title="Set系列集合: 无序、不重复、无索引"></a>Set系列集合: 无序、不重复、无索引</h3><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609154609801.png" alt="image-20240609154609801" style="zoom:33%;">

<p>创建一个Set（接口）集合的对象，Set是接口不能创建Set的对象，要创建他的实现类的对象，需要使用Set接口里的方法，因此创建多态的方式创建对象</p>
<blockquote>
<p>Set <String>  &#x3D; new  HashSet&lt;&gt;() </String></p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621124517384.png" alt="image-20240621124517384" style="zoom:33%;">

<p>哈希值：对象的整数表示，哈希值来确定当前对象添加在数组的哪个位置</p>
</blockquote>
<p>如果集合中存储的是自定义对象（像Sting、Integer的java底层已经重写好了），必须要重写** <strong>和</strong>equal<strong>方法，若没有重写他们在底层都是使用地址值进行计算和比较的， 意义不大，重写后根据对象的属性值进行计算</strong>哈希值<strong>和比较</strong>属性值**。</p>
<ul>
<li><p>HashSet:该集合底层采用<strong>哈希表</strong>存储数据</p>
</li>
<li><p>哈希表组成：</p>
<ul>
<li>JDK8之前：数组+链表</li>
<li>JDK8之后：数组+链表+红黑树</li>
</ul>
</li>
<li><p>LinkedHashSet：</p>
<ul>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609155239192.png" alt="image-20240609155239192" style="zoom:50%;"></li>
</ul>
</li>
<li><p>TreeSet：该集合底层是<strong>基于红黑树的数据结构</strong>实现排序的，增删改查性能都较好</p>
<ul>
<li><p>TreeSet排序时的两种比较方式：</p>
<ul>
<li>默认排序&#x2F;自然排序：Javabean类实现Comparable接口，指定比较规则，this表示需要添加的元素，o表示已经在红黑树中存在的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span>&#123;</span><br><span class="line">  <span class="comment">//指定排序的规则</span></span><br><span class="line">  <span class="comment">//只看年龄，按照年龄生序排列</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.getAge() - o.getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609165309617.png" alt="image-20240609165309617"></p>
<ul>
<li>比较器排序：创建集合时，自定义Comparator比较器对象，指定比较规则（在创建TreeSet对象的时候，传递比较器的对象）,<strong>o1表示当前要添加的元素，o2表示已经存在红黑树存在的元素</strong></li>
</ul>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609170647023.png" alt="image-20240609170647023" style="zoom:33%;">

<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609170714439.png" alt="image-20240609170714439" style="zoom:33%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">TreeSet&lt;Teacher&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Teacher&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Teacher o1, Teacher o2)</span> &#123;</span><br><span class="line">    <span class="comment">//o1表示现在要存入的那个元素</span></span><br><span class="line">    <span class="comment">//o2表示已经存入到集合中的元素</span></span><br><span class="line">              </span><br><span class="line">    <span class="comment">//主要条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o1.getAge() - o2.getAge();</span><br><span class="line">    <span class="comment">//次要条件,如果结果为0则按照字符串默认的排序规则o1.getName()是一个字符串，按照首字母排序</span></span><br><span class="line">    result = result == <span class="number">0</span> ? o1.getName().compareTo(o2.getName()) : result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>



<ul>
<li>默认使用第一种，如果第一种不能满足当前需求，就是用第二种（例如String字符串的排序规则在java底层已经写好了默认的排序，我们要进行更改就需要使用第二种方式重新排序 ）</li>
<li>两种排序方式都存在，使用第二种<ul>
<li>对象进行排序</li>
<li>实现Comparable接口，指定比较规则</li>
<li>创建集合时传递Comparator比较器对象，指定比较规则 ，Arrays类提供了重载的sorts方法</li>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240716155524563.png" alt="image-20240716155524563" style="zoom:33%;"></li>
</ul>
</li>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240716154939165.png" alt="image-20240716154939165"></li>
</ul>
</li>
<li><p>两种方式中关于返回值的规则</p>
<ul>
<li>如果返回值为负数，表示当前存入的元素是较小值，存左边</li>
<li>如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存</li>
<li>如果返回值为正数，表示当前存入的元素是较大值，存右边</li>
</ul>
</li>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240609165647699.png" alt="image-20240609165647699" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Lambda不受限于面向对象的语法特征（先创建对象，在写方法体）lambda表达式可以直接写方法体。</p>
<ul>
<li>Lambda表达式的注意点：<ul>
<li>Lambda表达式可以用来简化匿名内部类的书写</li>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法（调用一个方法的时候，如果方法的形参是一个接口，那么我们要传递这个接口的实现类对象，如果实现类对象只要用到一次，就可以用匿名内部类的形式书写）</li>
<li><strong>函数式接口</strong>：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解</li>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240716130445052.png" alt="image-20240716130445052"></li>
<li>实现一个接口需要重写里面所有的抽象方法，在没有名字的类中重写接口的抽象方法</li>
</ul>
</li>
<li>Lambda的省略规则：<ul>
<li>参数类型可以省略不写</li>
<li>如果只有一个参数，参数类型可以省略，同时()也可以省略</li>
<li>如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。</li>
</ul>
</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605100310461.png" alt="image-20240605100310461"></p>
<h3 id="Map双列集合"><a href="#Map双列集合" class="headerlink" title="Map双列集合"></a>Map双列集合</h3><p>Map是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的，接口不能直接创建对象需要创建实现类的对象，即多态的方式创建对象。</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621101448548.png" alt="image-20240621101448548" style="zoom:25%;">

<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621122653973.png" alt="image-20240621122653973" style="zoom:50%;">

<p>双列集合一次需要存一对数据，分为键和值</p>
<p>键值对–键值对对象–Entry对象</p>
<ul>
<li><p>put方法：添加&#x2F;覆盖</p>
<ul>
<li>在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null</li>
<li>在添加数据的时候，如果键存在，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回</li>
</ul>
</li>
<li><p>Map的遍历方式：1.键找值 2.键值对 3.Lambda表达式</p>
<ul>
<li><p><strong>第一种键找值</strong></p>
</li>
<li><p>获取所有键的集合。用keySet()方法实现</p>
</li>
<li><p>遍历键的集合，获取到每一个键。用增强for、迭代器或者lambda实现  </p>
</li>
<li><p>根据键去找值。用get(Object key)方法实现</p>
</li>
<li><p><strong>第二种键值对</strong>，依次获取所有的键值对对象</p>
</li>
<li><p>获取所有键值对对象的集合</p>
<ul>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合</li>
</ul>
</li>
<li><p>遍历键值对对象的集合，得到每一个键值对对象</p>
<ul>
<li>用增强for实现，得到每一个Map.Entry</li>
</ul>
</li>
<li><p>根据键值对对象获取键和值</p>
<ul>
<li>用getKey()得到键</li>
<li>用getValue()得到值</li>
</ul>
</li>
<li><p><strong>第三种Lambda表达式遍历</strong></p>
</li>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621112123580.png" alt="image-20240621112123580" style="zoom:33%;"></li>
<li><p>Hashmap</p>
</li>
</ul>
<ul>
<li>HashMap底层是哈希表结构的</li>
<li>依赖hashCode方法和equals方法保证键的唯一：通过hashcode方法计算键的哈希值找到数组当中应存入的位置，如果该位置有元素，就是用equals方法比较键是否相同</li>
<li>如果键要存储的是自定义对象，需要重写hashCode和equals方法</li>
</ul>
</li>
<li><p>LinkedHashMap:</p>
</li>
</ul>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621194423556.png" alt="image-20240621194423556" style="zoom:33%;">

<ul>
<li><p>TreeMap：</p>
<ul>
<li>TreeMap底层是红黑树结构</li>
<li>依赖自然排序或者比较器排序,对键进行排序</li>
<li>如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则</li>
<li>实现Comparable接口（i&#x3D;&#x3D;0 ? this.getName().compareTo(o.getName)）:i;–年龄一样按照姓名去比</li>
<li>compareTo底层是按照字符串中每一个字符在ascii表中的数字排列的</li>
</ul>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240621202147429.png" alt="image-20240621202147429" style="zoom:33%;">



<ul>
<li></li>
</ul>
</li>
</ul>
<ol start="28">
<li>递归指的是方法中调用方法本身的现象，递归一定要有出口(什么时候不在调用方法)，否则就会出现内存溢出。</li>
</ol>
<p>心得：方法内部再次调用方法的时候，参数必须要更加的靠近出口。</p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605171208922.png" alt="image-20240605171208922"></p>
<p>快速排序使用了递归</p>
<h2 id="排序总结："><a href="#排序总结：" class="headerlink" title="排序总结："></a>排序总结：</h2><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240605201112874.png" alt="image-20240605201112874" style="zoom:33%;">

<h2 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h2><ul>
<li>如果我们没有给集合制定类型，默认认为所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型。</li>
<li>泛型，在添加数据的时候把类型进行统一</li>
<li>Java中的泛型是违泛型，使用泛型的时候数据存进去后数据还是会变成Object类型，在向外获取的时候，java集合底层会将Object类型按照泛型进行强转。</li>
<li>泛型类、泛型方法、泛型接口</li>
</ul>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606161803755.png" alt="image-20240606161803755" style="zoom:33%;">

<ul>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606163713815.png" alt="image-20240606163713815" style="zoom:33%;">
</li>
<li><p>泛型的通配符：</p>
</li>
</ul>
<p>Public static<E> void keepPet(ArrayList<E> list){}—–&gt;Public static (可省略) void keepPet(ArrayList&lt;?&gt; list){}，**<E>要写在修饰符的后面，Public static都为修饰符**</E></E></E></p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606192504208.png" alt="image-20240606192504208" style="zoom:50%;">

<ul>
<li>泛型不具备继承性，但是数据具备继承性</li>
</ul>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240606193438140.png" alt="image-20240606193438140" style="zoom:33%;">



<h2 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h2><p>与时间复杂度类似，一般也适用大O表示法来衡量，一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本。</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240607214322504.png" alt="image-20240607214322504" style="zoom:50%;">

<ol start="31">
<li>平衡二叉树：任意节点的左右两个子树高度差不超过1</li>
</ol>
<ul>
<li><p>平衡二叉树旋转的四种情况</p>
<ul>
<li><p>左左</p>
<ul>
<li><p>左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡</p>
</li>
<li><p>如何旋转: 直接对整体进行右旋即可</p>
</li>
</ul>
</li>
<li><p>左右</p>
<ul>
<li><p>左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡</p>
</li>
<li><p>如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋</p>
</li>
</ul>
</li>
<li><p>右右</p>
<ul>
<li><p>右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡</p>
</li>
<li><p>如何旋转: 直接对整体进行左旋即可</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>右左</p>
<ul>
<li><p>右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡</p>
</li>
<li><p>如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="红黑树："><a href="#红黑树：" class="headerlink" title="红黑树："></a>红黑树：</h2><p>节点组成如下，是一种特殊的二叉查找树</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240608201105900.png" alt="image-20240608201105900" style="zoom:33%;">

<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240608203557746.png" alt="image-20240608203557746"></p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240608203531737.png" alt="image-20240608203531737"></p>
<ol start="34">
<li>链表中会存在内部类用来表示节点，一个节点由三部分构成</li>
</ol>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240613102244352.png" alt="image-20240613102244352"></p>
<ol start="35">
<li><p>在Java中，entry一词通常用来指代程序的入口点（即main方法）或Map集合中的键值对。</p>
</li>
<li><p><strong>核心线程数 （corePoolSize）</strong>：核心线程的数量；它的作用可以这样理解：向线程池中添加任务，如果线程池中的线程数量小于 corePoolSize，那么直接新建线程执行任务；如果线程池中的线程数量大于corePoolSize，那么就会往 阻塞队列workQueue中添加任务，此时如果阻塞队列满了且线程池中的线程数量小于最大线程数 maximumPoolSize，那么也会新建一个线程执行任务；如果阻塞队列满且线程数量大于最大线程数maximumPoolSize，那么会执行饱和策略，默认的策略是抛弃要加入的任务。</p>
</li>
<li><p>移除数组元素的方法：快慢指针</p>
</li>
</ol>
<ul>
<li>快指针：用来获取新数组中的元素</li>
<li>慢指针：获取我们新数组中需要更新的位置</li>
</ul>
<ol start="38">
<li>MySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TRANSACTION</code>。</li>
</ol>
<p>​	只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li><p>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</p>
</li>
<li><p>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p>
</li>
<li><h3 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="如何分析 SQL 的性能？"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD">如何分析 SQL 的性能？</a></h3></li>
<li><p>dump 线程</p>
</li>
<li><p>binlog、relay log</p>
</li>
<li><p>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</p>
</li>
</ul>
<ol start="39">
<li><p>JDK上对toString方法的解释是：返回对象的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA&spm=1001.2101.3001.7020">字符串表示</a>形式。一般来说，toString方法返回一个“文本表示”此对象的字符串,    Object类的toString方法返回一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>，该字符串由该对象作为其实例的类的名称、@符号字符以及该对象哈希码的无符号十六进制表示形式组成。</p>
<blockquote>
<p>类名+@+哈希码</p>
</blockquote>
</li>
</ol>
<p>40.数据包与数据帧的区别</p>
<ol>
<li><p><strong>传输层级</strong>：</p>
<ul>
<li><strong>数据包</strong>：工作在网络层，用于跨网络的节点之间进行传输。</li>
<li><strong>数据帧</strong>：工作在链路层，用于直接相连的设备之间传输。</li>
</ul>
</li>
<li><p><strong>地址信息</strong>：</p>
<ul>
<li><strong>数据包</strong>：包含IP地址信息（源IP和目的IP），用于网络层的路由和寻址。</li>
<li><strong>数据帧</strong>：包含MAC地址信息（源MAC和目的MAC），用于链路层的设备通信。</li>
</ul>
</li>
<li><p><strong>错误检测</strong>：</p>
<ul>
<li><strong>数据包</strong>：可能包含校验和，用于检测IP包头的错误。</li>
<li><strong>数据帧</strong>：通常包含冗余校验码（CRC），用于检测整个帧的数据错误。</li>
</ul>
</li>
<li><p><strong>封装关系</strong>：</p>
<ul>
<li><strong>数据包</strong>：可能被封装在数据帧的帧体部分进行传输。</li>
<li><strong>数据帧</strong>：在链路层传输的基本单元，其帧体部分可以包含网络层的数据包。</li>
</ul>
</li>
<li><p><strong>网络层的的核心功能——转发与路由</strong>，必会！！！如果面试官问到了网络层，而你恰好又什么都不会的话，最最起码要说出这五个字——<strong>转发与路由</strong>。</p>
</li>
</ol>
<ul>
<li>转发：将分组从路由器的输入端口转移到合适的输出端口。</li>
<li>路由：确定分组从源到目的经过的路径。</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240622210900940.png" alt="image-20240622210900940"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助Mysql高效获取数据的数据结构（有序），数据库中的数据是存储在磁盘当中的，操作磁盘涉及到磁盘的I&#x2F;O，降低数据库的IO成本。</p>
<p>​		MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<ul>
<li>二叉树的缺点：顺序插入时候，会形成一个链表，查询性能大大降低。大数据情况下，层级较深，检索速度满。</li>
<li>红黑树是自平衡二叉树，解决树的平衡问题，但依然存在大数据情况下，层级较深，检索速度满。</li>
<li>B树是<strong>多路</strong>平衡查找树，多路–》一个节点可以包含多个字节点，4个key对应5个指针，分别指向它的子节点。</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623164159422.png" alt="image-20240623164159422"></p>
<ul>
<li>B+树 ：所有的数据都会出现在叶子节点、叶子节点形成一个单向链表</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623164511878.png" alt="image-20240623164511878"></p>
<ul>
<li>Mysql使用的优化后的B+树索引结构，只有叶子节点存储数据，其他节点只起到索引数据的作用，每个节点都存储在页&#x2F;磁盘块上，页&#x2F;块大小为16K</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623164737468.png" alt="image-20240623164737468"></p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623165950891.png" alt="image-20240623165950891"></p>
<ul>
<li>Hash索引：</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623165335859.png" alt="image-20240623165335859"></p>
<ul>
<li><p>索引分类（在InnDB存储引擎中分为两种），一般索引分类有四种：主键索引(默认自动创建，只能有一个)、唯一索引、常规索引、全文索引</p>
<ul>
<li><strong>聚集索引</strong>：B+树的叶子节点下面存放的是这一行的数据</li>
<li><strong>二级索引</strong>：B+树的叶子节点下面存放的是这一行的id（主键值）</li>
<li>回表查询：先走二级索引找到对应的主键值，再根据主键值到聚集索引中获取这一行的数据</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623171123177.png" alt="image-20240623171123177"></p>
</li>
</ul>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623171049100.png" alt="image-20240623171049100"></p>
<h2 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h2><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240623220352355.png" alt="image-20240623220352355" style="zoom:25%;">

<h2 id="二进制日志binlog，记录的是DDL和DML语句"><a href="#二进制日志binlog，记录的是DDL和DML语句" class="headerlink" title="二进制日志binlog，记录的是DDL和DML语句"></a>二进制日志binlog，记录的是DDL和DML语句</h2><p>日志格式：由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看。 </p>
<ul>
<li>statement：基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的Sql都会记录在日志文件中</li>
<li>row：基于行的日志记录，记录的是每一行的数据变更（默认）。</li>
<li>mixed：混合statement和row两种格式，默认采用statement，在某些特殊情况下会自动切换为row进行记录</li>
</ul>
<p>redo log就是为了保证在进行脏页刷新发生错误时 进行数据恢复，从而保证数据的持久性</p>
<ul>
<li>缓冲池中的数据页发生了变更，而磁盘中的没有变更，该数据页为脏页，需要把脏页刷新到磁盘当中，是的缓冲区当中的数据和磁盘当中的数据保持一致，脏页数据并不是实时刷新，而是一段时间之后通过后台线程数刷新。</li>
<li>当对缓冲区的数据进行增删改的时候，把该数据记录到redolog buffer（记录数据页的物理变化），事务提交的时候将redolog buffer刷新到磁盘到中持久化的保存到磁盘文件当中</li>
<li>当脏页数据刷新到磁盘发生错误时，通过redolog（记录档次错误的变化）恢复</li>
<li>日志文件是追加的，是顺序磁盘IO高于随机磁盘IO</li>
<li>当脏页数据顺利刷新后，redolog对应的数据变更也就删除，清理redolog日志</li>
</ul>
<h2 id="InnoDB存储引擎的逻辑结构"><a href="#InnoDB存储引擎的逻辑结构" class="headerlink" title="InnoDB存储引擎的逻辑结构"></a>InnoDB存储引擎的逻辑结构</h2><p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240624170019918.png" alt="image-20240624170019918"></p>
<p>内存和磁盘结构</p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240624173900431.png" alt="image-20240624173900431"></p>
<p>后台线程：将InnoDB存储引擎缓冲池中的数据在合适的时机刷新到磁盘文件当中，AIO异步非阻塞IO</p>
<p><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240624174319493.png" alt="image-20240624174319493"></p>
<h2 id="Redis三种持久化方式："><a href="#Redis三种持久化方式：" class="headerlink" title="Redis三种持久化方式："></a>Redis三种持久化方式：</h2><ul>
<li><p>快照（snapshotting，RDB）：Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
</li>
<li><p>只追加文件（append-only file, AOF）以日志的形式记录每个写的操作,将Redis执行过的所有命令记录下来,读的操作不记录,只许追加文件,不可以改写文件,Redis启动的时候会读取该文件重新构建数据</p>
<ul>
<li><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略）</p>
</li>
<li><pre><code>appendfsync always
appendfsync everysec
appendfsync no
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * **这 3 种持久化方式的主要区别在于 `fsync` 同步 AOF 文件的时机（刷盘）**</span><br><span class="line"></span><br><span class="line">* RDB 和 AOF 的混合持久化(Redis 4.0 新增)</span><br><span class="line"></span><br><span class="line">47. 缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</span><br><span class="line"></span><br><span class="line">    缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。</span><br><span class="line"></span><br><span class="line">    缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。** 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</span><br><span class="line"></span><br><span class="line">    缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</span><br><span class="line"></span><br><span class="line">48. 使用缓存的时候，我们经常需要对内存中的数据进行**持久化**也就是**将内存中的数据写入到硬盘**中。</span><br><span class="line"></span><br><span class="line">49. `@Autowired` 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</span><br><span class="line"></span><br><span class="line">50. **发生循环依赖**是因为在对 A 中的属性 B 进行注入时，注入的是 B 对象，此时又会去初始化 B 对象，发现 B 又依赖了 A，因此才导致的循环依赖</span><br><span class="line"></span><br><span class="line">​	**循环依赖问题是如何通过`@Lazy` 解决的呢？**这里举一个例子，比如说有两个 Bean，A 和 B，他们之间发生了循环依赖，那么 A 的构造器上添加 `@Lazy` 注解之后（延迟 Bean B 的实例化），加载的流程如下：</span><br><span class="line"></span><br><span class="line">- 首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</span><br><span class="line">- 由于在 A 上标注了 `@Lazy` 注解，因此 Spring 会去**创建一个 B 的代理对象**，将这个代理对象注入到 A 中的 B 属性；</span><br><span class="line">- 之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</span><br><span class="line"></span><br><span class="line">通过 `@Lazy` 就解决了循环依赖的注入， 关键点就在于对 A 中的属性 B 进行注入时，注入的是 B 的代理对象，因此不会循环依赖。</span><br><span class="line"></span><br><span class="line">51.`@Transient` 注解用于标记某个实体类字段不会被持久化到数据库中。这个字段在实体类中仅用于临时数据存储，且不应该参与数据库的映射操作。</span><br><span class="line"></span><br><span class="line">52.** Serializable**接口里面是没有抽象方法，标记型接口</span><br><span class="line">**** *一旦实现了这个接口，那么就表示当前的**BusinessDataVO**类可以被序列化*</span><br><span class="line"></span><br><span class="line">53. ### `wait()` 方法</span><br><span class="line"></span><br><span class="line">    当一个线程调用某个对象的 `wait()` 方法时，它会进入该对象的等待池（wait set）中，并放弃该对象的锁（monitor），使得其他线程可以获得该锁并执行。</span><br><span class="line"></span><br><span class="line">    ### `notify()` 方法</span><br><span class="line"></span><br><span class="line">    当一个线程调用某个对象的 `notify()` 方法时，会从该对象的等待池中随机唤醒一个等待该对象的线程，使得该线程能够重新获得该对象的锁并继续执行。</span><br><span class="line"></span><br><span class="line">### `notifyAll()` 方法</span><br><span class="line"></span><br><span class="line">当一个线程调用某个对象的 `notifyAll()` 方法时，会唤醒所有等待该对象的线程。这些被唤醒的线程会竞争重新获得该对象的锁，只有一个线程能成功获得锁并继续执行。</span><br><span class="line"></span><br><span class="line"> 为什么不能直接调用 `run()` 方法</span><br><span class="line"></span><br><span class="line">- **直接调用 `run()` 方法**：只是一个普通的方法调用，不会创建新的线程。方法会在当前线程中运行，直到方法执行完毕。</span><br><span class="line">- **调用 `start()` 方法**：`start()` 方法会创建一个新的线程，并且由 JVM 调用 `run()` 方法，从而实现并发执行。</span><br><span class="line"></span><br><span class="line">## MVCC</span><br><span class="line"></span><br><span class="line">* 当前读：读取的是记录的最新版本，读取时还要保证其他并发食物不能修改当前记录，会对读取的记录加锁。</span><br><span class="line">* 快照读：简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本。有可能是历史数据</span><br><span class="line">  * Read Committed：每次select，都生成一个快照读</span><br><span class="line">  * Repeatable Read：开启事务后第一个select语句才是快照读的地方，**也就是第一个select语句会产生数据的快照，后面select直接读取这个快照就行。**</span><br><span class="line">  * Serializable：快照读会退化为当前读</span><br><span class="line"></span><br><span class="line">* InnoDB对MVCC实现的三个字段：ibd文件是独立表空间文件</span><br><span class="line"></span><br><span class="line">  * 隐藏字段：DB_TRX_ID(Transaction)是自增的、DB_ROLL_PTR(pointer)、DB_ROW_ID(如果一张表有主见就不会出现这个)</span><br><span class="line">  * 分别为**最近修改事务ID**、**回滚指针**、**隐藏字段**</span><br><span class="line">  * ![image-20240708204458165](Java八股.assets/image-20240708204458165.png)</span><br><span class="line">  * ReadView：读视图，是**快照读**SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃事务（为提交的）id，ReadView包含了四个核心字段。</span><br><span class="line"></span><br><span class="line">  ![image-20240708214215536](Java八股.assets/image-20240708214215536.png)</span><br><span class="line"></span><br><span class="line">  ![ ](Java八股.assets/image-20240708214322878.png)</span><br><span class="line"></span><br><span class="line">  * undo.log：不同食物或者相同事物对同一记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表的尾部是最早的旧记录，**当insert的时候**，产生的undo.log日志只在回归时候需要，在事物提交后，可以立即被删除。**当update、delete的时候，产生的undo log日志不仅在回滚的时候需要，在快照读的时候也需要，不会被理解删除。**</span><br><span class="line"></span><br><span class="line">​			`undo log` 包含了在事务提交前需要撤销的操作，必须保证这些日志在崩溃后也能够被正确回滚。			如果仅仅将 `undo log` 保存在内存中，崩溃时这些日志可能会丢失，从而无法回滚未提交的事务。			将 `undo log` 的信息记录到 `redo log` 中，可以确保这些日志在崩溃后也能被恢复。</span><br><span class="line"></span><br><span class="line">* MVCC加锁实现隔离型，redo.log和undo.log用来保证事务的一致性</span><br><span class="line"></span><br><span class="line">55. 事务的四大特性是怎么实现的</span><br><span class="line"></span><br><span class="line">* 原子性：undo.log回滚日志保证事务的原子性。</span><br><span class="line">* 持久性：redo.log，缓冲区中的脏页刷新到磁盘的过程中出现问题，可以通过redo.log来恢复，从而保证数据的持久性。</span><br><span class="line">* 一致性：undo.log+redo.log</span><br><span class="line">* 隔离性：锁+MVCC</span><br><span class="line"></span><br><span class="line">56. insert 操作的记录只对事务本身可见，对其他事务不可见” 这句话意味着：</span><br><span class="line"></span><br><span class="line">- 当一个事务 A 执行 `INSERT` 操作时，插入的记录对事务 A 本身是可见的。</span><br><span class="line">- 但在事务 A 提交之前，其他事务（如事务 B）是看不到这些新插入的记录的。</span><br><span class="line"></span><br><span class="line">## MySQL中的锁：</span><br><span class="line"></span><br><span class="line">* 全局锁：**锁的力度很大，锁太重了**，锁定数据库中的所有表：典型使用场景是**做全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性，mysqldump工具用于备份。在InnoDB引擎中，我们可以在备份时加上参数--single- transaction参数来完成不加锁的一致性数据备份。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;Java八股.assets/image-20240719210154363.png&quot; alt=&quot;image-20240719210154363&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* 表级锁：每次操作锁住整张表，锁定力度大，发生锁冲突的概率最高，并发度最低</span><br><span class="line"></span><br><span class="line">  * **表锁**：表共享读锁和表独占写锁</span><br><span class="line">  * **元数据锁**(meta data lock,MDL)</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;Java八股.assets/image-20240719212737675.png&quot; alt=&quot;image-20240719212737675&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  * **意向锁**</span><br><span class="line"></span><br><span class="line">* 行级锁：每次操作锁住对应的行数据，锁定力度最小，发生锁冲突的概率最低，并发度最高，应用在InnoDB存储引擎中。   **事务、外键、行级锁，MyISAM和InnDB的区别**</span><br><span class="line"></span><br><span class="line">![image-20240723215915667](Java八股.assets/image-20240723215915667.png)</span><br><span class="line"></span><br><span class="line">​	InnoDB实现两种行锁，共享锁(S)和排他锁(X)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240723220947133.png&quot; alt=&quot;image-20240723220947133&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240723223216374.png&quot; alt=&quot;image-20240723223216374&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">关于第二点：为啥退化？首先明白，间隙锁锁的是两个值之间的间隙，而临建锁锁的是当前锁的值加上值前面的间隙，所以这里就是18-29之间的间隙锁了，但是29没锁，所以是退化为间隙锁，但是18前面的间隙和18则是临建锁。</span><br><span class="line"></span><br><span class="line">下图是第三点的例子</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240723222829442.png&quot; alt=&quot;image-20240723222829442&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">58. 为什么undo log 的信息也会被记录到 redo log 中？</span><br><span class="line"></span><br><span class="line">**确保undo.log的持久性**，`undo log` 包含了在事务提交前需要撤销的操作，必须保证这些日志在崩溃后也能够被正确回滚。如果仅仅将 `undo log` 保存在内存中，崩溃时这些日志可能会丢失，从而无法回滚未提交的事务。将 `undo log` 的信息记录到 `redo log` 中，可以确保这些日志在崩溃后也能被恢复。</span><br><span class="line"></span><br><span class="line">1. 确保数据一致性和完整性</span><br><span class="line"></span><br><span class="line">在事务处理过程中，数据的一致性和完整性是至关重要的。通过将 `undo log` 的信息记录到 `redo log` 中，数据库系统可以确保在崩溃恢复期间，所有已提交的事务都能够正确地恢复。</span><br><span class="line"></span><br><span class="line">- **Redo log**：用于重做已提交的事务，确保在崩溃恢复后，所有已提交的事务都能正确地反映在数据文件中。</span><br><span class="line">- **Undo log**：用于回滚未提交的事务，支持 MVCC（多版本并发控制），提供一致性读。</span><br><span class="line"></span><br><span class="line">2. 崩溃恢复的需要</span><br><span class="line"></span><br><span class="line">当数据库系统崩溃时，需要通过 `redo log` 来恢复未完成的事务，以确保数据库的一致性。`redo log` 包含了所有已提交和未提交事务的更改，包括 `undo log` 的更改。</span><br><span class="line"></span><br><span class="line">- 崩溃恢复过程</span><br><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  1. **应用 redo log**：在崩溃恢复期间，首先通过 `redo log` 重做所有已提交的事务，这包括重做 `undo log` 的更改。</span><br><span class="line">  2. **回滚未提交事务**：通过 `undo log` 回滚未提交的事务。由于 `undo log` 的更改已经记录在 `redo log` 中，即使在崩溃后，也可以确保 `undo log` 的数据完整性。</span><br><span class="line"></span><br><span class="line">3. 确保 undo log 的持久性</span><br><span class="line"></span><br><span class="line">`undo log` 包含了在事务提交前需要撤销的操作，必须保证这些日志在崩溃后也能够被正确回滚。如果仅仅将 `undo log` 保存在内存中，崩溃时这些日志可能会丢失，从而无法回滚未提交的事务。将 `undo log` 的信息记录到 `redo log` 中，可以确保这些日志在崩溃后也能被恢复。</span><br><span class="line"></span><br><span class="line">4. 实现原理</span><br><span class="line"></span><br><span class="line">在 InnoDB 中，`redo log` 是一种物理日志，记录了数据页的物理更改。而 `undo log` 是一种逻辑日志，记录了每一条数据更改前的状态。当事务修改数据时，以下操作会发生：</span><br><span class="line"></span><br><span class="line">1. **记录 undo log**：在修改数据之前，记录一条 `undo log`，保存数据的旧版本。</span><br><span class="line">2. **修改数据**：执行数据修改操作。</span><br><span class="line">3. **记录 redo log**：记录数据页的物理更改和 `undo log` 的写入操作。</span><br><span class="line"></span><br><span class="line">这种设计确保了在崩溃恢复期间，即使事务未提交，`undo log` 也能被恢复，允许未提交的事务被正确回滚。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">将 `undo log` 的信息记录到 `redo log` 中，主要有以下几个原因：</span><br><span class="line"></span><br><span class="line">- 确保数据一致性和完整性。</span><br><span class="line">- 支持崩溃恢复，能够正确重做和回滚事务。</span><br><span class="line">- 确保 `undo log` 的持久性，防止崩溃后日志丢失。</span><br><span class="line">- 简化了恢复过程，确保所有事务操作（包括未提交的操作）都能被正确处理。</span><br><span class="line"></span><br><span class="line">通过这种设计，数据库系统能够在崩溃后高效、可靠地恢复数据，确保事务的原子性和一致性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 方法引用：</span><br><span class="line"></span><br><span class="line">**把已经有的方法拿过来用，当作函数式接口中抽象方法的方法体**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java八股.assets/image-20240722170215676.png&quot; alt=&quot;image-20240722170215676&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">进一步简化Lambda表达式</span><br><span class="line"></span><br><span class="line">静态方法引用（类名::静态方法）：如果Lambda表达式里只是调用一个静态方法，并且前后参数的形式一致，就可以使用静态方法引用</span><br><span class="line"></span><br><span class="line">实例方法引用（对象名::实例方法）：如果Lambda表达式里只是调用一个实例方法，并且前后参数的形式一致，就可以使用静态方法引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240716152918886](Java八股.assets/image-20240716152918886.png)</span><br><span class="line"></span><br><span class="line">特定类型的方法的引用（类型::方法）</span><br><span class="line"></span><br><span class="line">![image-20240716154020237](Java八股.assets/image-20240716154020237.png)</span><br><span class="line"></span><br><span class="line">构造器引用（类名::new）</span><br><span class="line"></span><br><span class="line">如果某个Lambda表达式里只是在创建对象，并且前后参数情况一直，就可以使用构造器引用</span><br><span class="line"></span><br><span class="line">![image-20240716154420648](Java八股.assets/image-20240716154420648.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **Stream流的三类方法**</span><br><span class="line"></span><br><span class="line">![image-20240722145442364](Java八股.assets/image-20240722145442364.png)</span><br><span class="line"></span><br><span class="line">- 获取Stream流</span><br><span class="line"></span><br><span class="line">  - 创建一条流水线,并把数据放到流水线上准备进行操作</span><br><span class="line"></span><br><span class="line">- 中间方法</span><br><span class="line"></span><br><span class="line">  - 流水线上的操作</span><br><span class="line">  - 一次操作完毕之后,还可以继续进行其他操作</span><br><span class="line">  - **filter、limit、skip、distinct、concat、map**</span><br><span class="line">  - ![image-20240722145136003](Java八股.assets/image-20240722145136003.png)</span><br><span class="line"></span><br><span class="line">- 终结方法</span><br><span class="line"></span><br><span class="line">  - 一个Stream流只能有一个终结方法</span><br><span class="line"></span><br><span class="line">  - 是流水线上的最后一个操作</span><br><span class="line"></span><br><span class="line">  - **forEach、count、toArray、collect**</span><br><span class="line"></span><br><span class="line">  - &lt;img src=&quot;Java八股.assets/image-20240722145649333.png&quot; alt=&quot;image-20240722145649333&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  - toArray方法：IntFunction&lt;? extends Object[]&gt;中? extends Object[]`**：表示返回类型是某种 `Object` 数组的子类型</span><br><span class="line"></span><br><span class="line">  - &lt;img src=&quot;Java八股.assets/image-20240722150642848.png&quot; alt=&quot;image-20240722150642848&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  - collect方法，收集到list和set集合比较简单，但是收集到map集合中操作比较难，下面是个例子，**注意：如果我们要收集到Map集合中，键不能重复，负责会报错**，**这个很关键**</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Collectors.toMap()//源码</span><br><span class="line">    public static &lt;T, K, U&gt;</span><br><span class="line">        Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper) &#123;</span><br><span class="line">            return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);</span><br><span class="line">        &#125;</span><br><span class="line">    Function为函数式接口</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<ul>
<li><img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722163141817.png" alt="image-20240722163141817" style="zoom:33%;">

<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722163558060.png" alt="image-20240722163558060" style="zoom:33%;"></li>
</ul>
</li>
</ul>
<p><strong>生成Stream流的方式</strong></p>
<ul>
<li><p>Collection体系集合</p>
<p>使用默认方法stream()生成流， default Stream<E> stream() ，并把数据放到流当中</E></p>
</li>
<li><p>Map体系集合</p>
<p>把Map转成Set集合，间接的生成流</p>
</li>
<li><p>数组</p>
<p>通过Arrays中的静态方法stream生成流</p>
</li>
<li><p>同种数据类型的多个数据</p>
<p>通过Stream接口的静态方法of(T… values)生成流</p>
</li>
</ul>
<p>map转换流中的数据类型操作：（中间方法）</p>
<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722162754816.png" alt="image-20240722162754816" style="zoom:33%;">

<img src="/2024/07/24/java%E7%9B%B8%E5%85%B3/image-20240722145232077.png" alt="image-20240722145232077" style="zoom:33%;">



<h2 id="Sql性能分析"><a href="#Sql性能分析" class="headerlink" title="Sql性能分析"></a>Sql性能分析</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hungyeye.github.io">Hungyeye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hungyeye.github.io/2024/07/24/java%E7%9B%B8%E5%85%B3/">https://hungyeye.github.io/2024/07/24/java%E7%9B%B8%E5%85%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hungyeye.github.io" target="_blank">Hungyeye's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover/0.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/29/spring%E7%AC%94%E8%AE%B0/" title="spring笔记"><img class="cover" src="/img/cover/2.PNG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">spring笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title=""><img class="cover" src="/img/cover/3.PNG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hungyeye</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hungyeye"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hungyeye" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1326358725@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，与你共同进步 --小狗蛋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">对象和对象引用的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88"><span class="toc-number"></span> <span class="toc-text">Collection集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">Collection单列集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%97%A0%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">List中常见的方法和无种遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">ArrayList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88-%E6%97%A0%E5%BA%8F%E3%80%81%E4%B8%8D%E9%87%8D%E5%A4%8D%E3%80%81%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">4.</span> <span class="toc-text">Set系列集合: 无序、不重复、无索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">Map双列集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">排序总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">泛型：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">空间复杂度：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">红黑树：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-SQL-%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">如何分析 SQL 的性能？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number"></span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number"></span> <span class="toc-text">TCP三次握手、四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97binlog%EF%BC%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E6%98%AFDDL%E5%92%8CDML%E8%AF%AD%E5%8F%A5"><span class="toc-number"></span> <span class="toc-text">二进制日志binlog，记录的是DDL和DML语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">InnoDB存储引擎的逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%89%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">Redis三种持久化方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">Sql性能分析</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="无题"><img src="/img/cover/3.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/08/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="无题">无题</a><time datetime="2024-08-15T02:04:59.744Z" title="发表于 2024-08-15 10:04:59">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/java%E7%9B%B8%E5%85%B3/" title="java相关"><img src="/img/cover/0.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java相关"/></a><div class="content"><a class="title" href="/2024/07/24/java%E7%9B%B8%E5%85%B3/" title="java相关">java相关</a><time datetime="2024-07-24T03:40:53.000Z" title="发表于 2024-07-24 11:40:53">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/29/spring%E7%AC%94%E8%AE%B0/" title="spring笔记"><img src="/img/cover/2.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="spring笔记"/></a><div class="content"><a class="title" href="/2024/05/29/spring%E7%AC%94%E8%AE%B0/" title="spring笔记">spring笔记</a><time datetime="2024-05-29T03:11:45.000Z" title="发表于 2024-05-29 11:11:45">2024-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E9%9A%8F%E7%AC%94/" title="随笔"><img src="/img/cover/3.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随笔"/></a><div class="content"><a class="title" href="/2024/05/16/%E9%9A%8F%E7%AC%94/" title="随笔">随笔</a><time datetime="2024-05-16T04:53:17.000Z" title="发表于 2024-05-16 12:53:17">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/15/spring/" title="spring"><img src="/img/cover/0.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="spring"/></a><div class="content"><a class="title" href="/2024/05/15/spring/" title="spring">spring</a><time datetime="2024-05-15T09:48:58.000Z" title="发表于 2024-05-15 17:48:58">2024-05-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Hungyeye</div><div class="footer_custom_text">Hi, welcome to hungyeye's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'hungyeye/hungyeye.github.io',
      'data-repo-id': 'R_kgDOL65qOw',
      'data-category-id': 'DIC_kwDOL65qO84CfXhF',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>